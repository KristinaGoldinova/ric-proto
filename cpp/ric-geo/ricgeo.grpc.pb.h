// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ric-geo/ricgeo.proto
#ifndef GRPC_ric_2dgeo_2fricgeo_2eproto__INCLUDED
#define GRPC_ric_2dgeo_2fricgeo_2eproto__INCLUDED

#include "ric-geo/ricgeo.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace ric {
namespace geo {

class Watch final {
 public:
  static constexpr char const* service_full_name() {
    return "ric.geo.Watch";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status WatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncWatchGeofenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchGeofenceRaw(context, request, cq));
    }
    virtual ::grpc::Status StopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncStopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncStopWatchGeofenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncStopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncStopWatchGeofenceRaw(context, request, cq));
    }
    virtual ::grpc::Status WatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncWatchRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status StopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncStopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncStopWatchRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncStopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncStopWatchRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status WatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncWatchRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchRouteRaw(context, request, cq));
    }
    virtual ::grpc::Status StopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncStopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncStopWatchRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncStopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncStopWatchRouteRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncUpdateGeoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncUpdateGeoRaw(context, request, cq));
    }
    virtual ::grpc::Status GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::ric::geo::GetObjectInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>> AsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>>(AsyncGetObjectInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>> PrepareAsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>>(PrepareAsyncGetObjectInfoRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void WatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WatchGeofence(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopWatchGeofence(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WatchRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopWatchRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WatchRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopWatchRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGeo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetObjectInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncStopWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncStopWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncStopWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncStopWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncStopWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncStopWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>* AsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>* PrepareAsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status WatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncWatchGeofenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchGeofenceRaw(context, request, cq));
    }
    ::grpc::Status StopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncStopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncStopWatchGeofenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncStopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncStopWatchGeofenceRaw(context, request, cq));
    }
    ::grpc::Status WatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncWatchRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchRoomRaw(context, request, cq));
    }
    ::grpc::Status StopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncStopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncStopWatchRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncStopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncStopWatchRoomRaw(context, request, cq));
    }
    ::grpc::Status WatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncWatchRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchRouteRaw(context, request, cq));
    }
    ::grpc::Status StopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncStopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncStopWatchRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncStopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncStopWatchRouteRaw(context, request, cq));
    }
    ::grpc::Status UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncUpdateGeoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncUpdateGeoRaw(context, request, cq));
    }
    ::grpc::Status GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::ric::geo::GetObjectInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>> AsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>>(AsyncGetObjectInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>> PrepareAsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>>(PrepareAsyncGetObjectInfoRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void WatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void WatchGeofence(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void StopWatchGeofence(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void StopWatchGeofence(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void WatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void WatchRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void StopWatchRoom(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void StopWatchRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void WatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void WatchRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void StopWatchRoute(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void StopWatchRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGeo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetObjectInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncStopWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncStopWatchGeofenceRaw(::grpc::ClientContext* context, const ::ric::geo::WatchGeofenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncStopWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncStopWatchRoomRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncStopWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncStopWatchRouteRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>* AsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>* PrepareAsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_WatchGeofence_;
    const ::grpc::internal::RpcMethod rpcmethod_StopWatchGeofence_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_StopWatchRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_WatchRoute_;
    const ::grpc::internal::RpcMethod rpcmethod_StopWatchRoute_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateGeo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetObjectInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WatchGeofence() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_WatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchGeofence(::grpc::ServerContext* context, ::ric::geo::WatchGeofenceRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopWatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopWatchGeofence() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_StopWatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopWatchGeofence(::grpc::ServerContext* context, ::ric::geo::WatchGeofenceRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WatchRoom() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_WatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchRoom(::grpc::ServerContext* context, ::ric::geo::WatchRoomRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopWatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopWatchRoom() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_StopWatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopWatchRoom(::grpc::ServerContext* context, ::ric::geo::WatchRoomRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WatchRoute() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_WatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchRoute(::grpc::ServerContext* context, ::ric::geo::WatchRouteRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopWatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopWatchRoute() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StopWatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopWatchRoute(::grpc::ServerContext* context, ::ric::geo::WatchRouteRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGeo(::grpc::ServerContext* context, ::ric::geo::UpdateGeoRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectInfo(::grpc::ServerContext* context, ::ric::geo::GetObjectInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::GetObjectInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_WatchGeofence<WithAsyncMethod_StopWatchGeofence<WithAsyncMethod_WatchRoom<WithAsyncMethod_StopWatchRoom<WithAsyncMethod_WatchRoute<WithAsyncMethod_StopWatchRoute<WithAsyncMethod_UpdateGeo<WithAsyncMethod_GetObjectInfo<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_WatchGeofence() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchGeofenceRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchGeofenceRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->WatchGeofence(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_WatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopWatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopWatchGeofence() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchGeofenceRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchGeofenceRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopWatchGeofence(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_StopWatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_WatchRoom() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchRoomRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchRoomRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->WatchRoom(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_WatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopWatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopWatchRoom() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchRoomRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchRoomRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopWatchRoom(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_StopWatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_WatchRoute() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchRouteRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchRouteRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->WatchRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_WatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopWatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopWatchRoute() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchRouteRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchRouteRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopWatchRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_StopWatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateGeo() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::UpdateGeoRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::UpdateGeoRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateGeo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetObjectInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::GetObjectInfoRequest, ::ric::geo::GetObjectInfoResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::GetObjectInfoRequest* request,
                 ::ric::geo::GetObjectInfoResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetObjectInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_WatchGeofence<ExperimentalWithCallbackMethod_StopWatchGeofence<ExperimentalWithCallbackMethod_WatchRoom<ExperimentalWithCallbackMethod_StopWatchRoom<ExperimentalWithCallbackMethod_WatchRoute<ExperimentalWithCallbackMethod_StopWatchRoute<ExperimentalWithCallbackMethod_UpdateGeo<ExperimentalWithCallbackMethod_GetObjectInfo<Service > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_WatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WatchGeofence() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_WatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopWatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopWatchGeofence() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_StopWatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WatchRoom() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_WatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopWatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopWatchRoom() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_StopWatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WatchRoute() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_WatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopWatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopWatchRoute() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StopWatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WatchGeofence() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_WatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchGeofence(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopWatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopWatchGeofence() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_StopWatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopWatchGeofence(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WatchRoom() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_WatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopWatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopWatchRoom() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_StopWatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopWatchRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WatchRoute() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_WatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatchRoute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopWatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopWatchRoute() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StopWatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopWatchRoute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGeo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchGeofence() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->WatchGeofence(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WatchGeofence(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopWatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopWatchGeofence() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopWatchGeofence(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopWatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopWatchGeofence(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchRoom() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->WatchRoom(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WatchRoom(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopWatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopWatchRoom() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopWatchRoom(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopWatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopWatchRoom(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_WatchRoute() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->WatchRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_WatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WatchRoute(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopWatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopWatchRoute() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopWatchRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopWatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopWatchRoute(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateGeo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateGeo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGeo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetObjectInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetObjectInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetObjectInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WatchGeofence() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchGeofenceRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_WatchGeofence<BaseClass>::StreamedWatchGeofence, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWatchGeofence(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchGeofenceRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopWatchGeofence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopWatchGeofence() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchGeofenceRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_StopWatchGeofence<BaseClass>::StreamedStopWatchGeofence, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopWatchGeofence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopWatchGeofence(::grpc::ServerContext* context, const ::ric::geo::WatchGeofenceRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopWatchGeofence(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchGeofenceRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WatchRoom() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchRoomRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_WatchRoom<BaseClass>::StreamedWatchRoom, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWatchRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchRoomRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopWatchRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopWatchRoom() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchRoomRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_StopWatchRoom<BaseClass>::StreamedStopWatchRoom, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopWatchRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopWatchRoom(::grpc::ServerContext* context, const ::ric::geo::WatchRoomRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopWatchRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchRoomRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WatchRoute() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchRouteRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_WatchRoute<BaseClass>::StreamedWatchRoute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWatchRoute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchRouteRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopWatchRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopWatchRoute() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchRouteRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_StopWatchRoute<BaseClass>::StreamedStopWatchRoute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopWatchRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopWatchRoute(::grpc::ServerContext* context, const ::ric::geo::WatchRouteRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopWatchRoute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchRouteRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::UpdateGeoRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_UpdateGeo<BaseClass>::StreamedUpdateGeo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateGeo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::UpdateGeoRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::GetObjectInfoRequest, ::ric::geo::GetObjectInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetObjectInfo<BaseClass>::StreamedGetObjectInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetObjectInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::GetObjectInfoRequest,::ric::geo::GetObjectInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_WatchGeofence<WithStreamedUnaryMethod_StopWatchGeofence<WithStreamedUnaryMethod_WatchRoom<WithStreamedUnaryMethod_StopWatchRoom<WithStreamedUnaryMethod_WatchRoute<WithStreamedUnaryMethod_StopWatchRoute<WithStreamedUnaryMethod_UpdateGeo<WithStreamedUnaryMethod_GetObjectInfo<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_WatchGeofence<WithStreamedUnaryMethod_StopWatchGeofence<WithStreamedUnaryMethod_WatchRoom<WithStreamedUnaryMethod_StopWatchRoom<WithStreamedUnaryMethod_WatchRoute<WithStreamedUnaryMethod_StopWatchRoute<WithStreamedUnaryMethod_UpdateGeo<WithStreamedUnaryMethod_GetObjectInfo<Service > > > > > > > > StreamedService;
};

class WatchV2 final {
 public:
  static constexpr char const* service_full_name() {
    return "ric.geo.WatchV2";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Watch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncWatch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncWatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncWatch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchRaw(context, request, cq));
    }
    virtual ::grpc::Status Stop(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncStop(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncStop(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncStopRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncUpdateGeoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncUpdateGeoRaw(context, request, cq));
    }
    virtual ::grpc::Status GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::ric::geo::GetObjectInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>> AsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>>(AsyncGetObjectInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>> PrepareAsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>>(PrepareAsyncGetObjectInfoRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Watch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Watch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGeo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetObjectInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncWatchRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncWatchRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncStopRaw(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>* AsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::GetObjectInfoResponse>* PrepareAsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Watch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncWatch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncWatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncWatch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncWatchRaw(context, request, cq));
    }
    ::grpc::Status Stop(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncStop(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncStop(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncStopRaw(context, request, cq));
    }
    ::grpc::Status UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncUpdateGeoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncUpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncUpdateGeoRaw(context, request, cq));
    }
    ::grpc::Status GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::ric::geo::GetObjectInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>> AsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>>(AsyncGetObjectInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>> PrepareAsyncGetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>>(PrepareAsyncGetObjectInfoRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Watch(::grpc::ClientContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void Watch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGeo(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGeo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void GetObjectInfo(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetObjectInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::GetObjectInfoResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncWatchRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncWatchRaw(::grpc::ClientContext* context, const ::ric::geo::WatchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncStopRaw(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::ric::geo::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncUpdateGeoRaw(::grpc::ClientContext* context, const ::ric::geo::UpdateGeoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>* AsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::GetObjectInfoResponse>* PrepareAsyncGetObjectInfoRaw(::grpc::ClientContext* context, const ::ric::geo::GetObjectInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Watch_;
    const ::grpc::internal::RpcMethod rpcmethod_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateGeo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetObjectInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response);
    virtual ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Watch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Watch() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Watch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatch(::grpc::ServerContext* context, ::ric::geo::WatchRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Stop() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::ric::geo::StopRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGeo(::grpc::ServerContext* context, ::ric::geo::UpdateGeoRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectInfo(::grpc::ServerContext* context, ::ric::geo::GetObjectInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::GetObjectInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Watch<WithAsyncMethod_Stop<WithAsyncMethod_UpdateGeo<WithAsyncMethod_GetObjectInfo<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Watch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Watch() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::WatchRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::WatchRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Watch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Watch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Stop() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::StopRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::StopRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Stop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateGeo() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::UpdateGeoRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::UpdateGeoRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateGeo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetObjectInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::GetObjectInfoRequest, ::ric::geo::GetObjectInfoResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::GetObjectInfoRequest* request,
                 ::ric::geo::GetObjectInfoResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetObjectInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Watch<ExperimentalWithCallbackMethod_Stop<ExperimentalWithCallbackMethod_UpdateGeo<ExperimentalWithCallbackMethod_GetObjectInfo<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Watch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Watch() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Watch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Stop() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Watch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Watch() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Watch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWatch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Stop() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGeo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetObjectInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Watch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Watch() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Watch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Watch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Watch(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Stop() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Stop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Stop(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateGeo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateGeo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGeo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetObjectInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetObjectInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetObjectInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Watch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Watch() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::WatchRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_Watch<BaseClass>::StreamedWatch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Watch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Watch(::grpc::ServerContext* context, const ::ric::geo::WatchRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWatch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::WatchRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Stop() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::StopRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_Stop<BaseClass>::StreamedStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stop(::grpc::ServerContext* context, const ::ric::geo::StopRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::StopRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateGeo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateGeo() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::UpdateGeoRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_UpdateGeo<BaseClass>::StreamedUpdateGeo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateGeo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateGeo(::grpc::ServerContext* context, const ::ric::geo::UpdateGeoRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateGeo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::UpdateGeoRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetObjectInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetObjectInfo() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::GetObjectInfoRequest, ::ric::geo::GetObjectInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetObjectInfo<BaseClass>::StreamedGetObjectInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetObjectInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetObjectInfo(::grpc::ServerContext* context, const ::ric::geo::GetObjectInfoRequest* request, ::ric::geo::GetObjectInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetObjectInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::GetObjectInfoRequest,::ric::geo::GetObjectInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Watch<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_UpdateGeo<WithStreamedUnaryMethod_GetObjectInfo<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Watch<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_UpdateGeo<WithStreamedUnaryMethod_GetObjectInfo<Service > > > > StreamedService;
};

class AttendanceControl final {
 public:
  static constexpr char const* service_full_name() {
    return "ric.geo.AttendanceControl";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Control(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::ric::geo::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> AsyncControl(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(AsyncControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>> PrepareAsyncControl(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>>(PrepareAsyncControlRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Control(::grpc::ClientContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Control(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* AsyncControlRaw(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::EmptyResponse>* PrepareAsyncControlRaw(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Control(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::ric::geo::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> AsyncControl(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(AsyncControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>> PrepareAsyncControl(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>>(PrepareAsyncControlRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Control(::grpc::ClientContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void Control(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* AsyncControlRaw(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::EmptyResponse>* PrepareAsyncControlRaw(::grpc::ClientContext* context, const ::ric::geo::ControlRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Control_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Control() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControl(::grpc::ServerContext* context, ::ric::geo::ControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Control<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Control() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::ControlRequest, ::ric::geo::EmptyResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::ControlRequest* request,
                 ::ric::geo::EmptyResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Control(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Control<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Control() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Control() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Control() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Control(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Control(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Control() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::ControlRequest, ::ric::geo::EmptyResponse>(std::bind(&WithStreamedUnaryMethod_Control<BaseClass>::StreamedControl, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Control(::grpc::ServerContext* context, const ::ric::geo::ControlRequest* request, ::ric::geo::EmptyResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::ControlRequest,::ric::geo::EmptyResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Control<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Control<Service > StreamedService;
};

class Osm final {
 public:
  static constexpr char const* service_full_name() {
    return "ric.geo.Osm";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Geocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::ric::geo::OsmResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>> AsyncGeocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>>(AsyncGeocodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>> PrepareAsyncGeocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>>(PrepareAsyncGeocodeRaw(context, request, cq));
    }
    virtual ::grpc::Status GeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::ric::geo::OsmResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>> AsyncGeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>>(AsyncGeocodeReverseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>> PrepareAsyncGeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>>(PrepareAsyncGeocodeReverseRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::ric::geo::OsmResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>> AsyncGetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>>(AsyncGetRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>> PrepareAsyncGetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>>(PrepareAsyncGetRouteRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Geocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Geocode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GeocodeReverse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>* AsyncGeocodeRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>* PrepareAsyncGeocodeRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>* AsyncGeocodeReverseRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>* PrepareAsyncGeocodeReverseRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>* AsyncGetRouteRaw(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::OsmResponse>* PrepareAsyncGetRouteRaw(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Geocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::ric::geo::OsmResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>> AsyncGeocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>>(AsyncGeocodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>> PrepareAsyncGeocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>>(PrepareAsyncGeocodeRaw(context, request, cq));
    }
    ::grpc::Status GeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::ric::geo::OsmResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>> AsyncGeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>>(AsyncGeocodeReverseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>> PrepareAsyncGeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>>(PrepareAsyncGeocodeReverseRaw(context, request, cq));
    }
    ::grpc::Status GetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::ric::geo::OsmResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>> AsyncGetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>>(AsyncGetRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>> PrepareAsyncGetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>>(PrepareAsyncGetRouteRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Geocode(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) override;
      void Geocode(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) override;
      void GeocodeReverse(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) override;
      void GeocodeReverse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRoute(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::OsmResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>* AsyncGeocodeRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>* PrepareAsyncGeocodeRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>* AsyncGeocodeReverseRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>* PrepareAsyncGeocodeReverseRaw(::grpc::ClientContext* context, const ::ric::geo::GeocodeReverseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>* AsyncGetRouteRaw(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::OsmResponse>* PrepareAsyncGetRouteRaw(::grpc::ClientContext* context, const ::ric::geo::GetRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Geocode_;
    const ::grpc::internal::RpcMethod rpcmethod_GeocodeReverse_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRoute_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response);
    virtual ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response);
    virtual ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Geocode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Geocode() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Geocode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGeocode(::grpc::ServerContext* context, ::ric::geo::GeocodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::OsmResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GeocodeReverse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GeocodeReverse() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GeocodeReverse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGeocodeReverse(::grpc::ServerContext* context, ::ric::geo::GeocodeReverseRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::OsmResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetRoute() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRoute(::grpc::ServerContext* context, ::ric::geo::GetRouteRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::OsmResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Geocode<WithAsyncMethod_GeocodeReverse<WithAsyncMethod_GetRoute<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Geocode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Geocode() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::GeocodeRequest, ::ric::geo::OsmResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::GeocodeRequest* request,
                 ::ric::geo::OsmResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Geocode(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Geocode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GeocodeReverse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GeocodeReverse() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::GeocodeReverseRequest, ::ric::geo::OsmResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::GeocodeReverseRequest* request,
                 ::ric::geo::OsmResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GeocodeReverse(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GeocodeReverse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetRoute() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::GetRouteRequest, ::ric::geo::OsmResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::GetRouteRequest* request,
                 ::ric::geo::OsmResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Geocode<ExperimentalWithCallbackMethod_GeocodeReverse<ExperimentalWithCallbackMethod_GetRoute<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Geocode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Geocode() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Geocode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GeocodeReverse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GeocodeReverse() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GeocodeReverse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetRoute() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Geocode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Geocode() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Geocode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGeocode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GeocodeReverse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GeocodeReverse() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GeocodeReverse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGeocodeReverse(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetRoute() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRoute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Geocode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Geocode() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Geocode(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Geocode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Geocode(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GeocodeReverse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GeocodeReverse() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GeocodeReverse(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GeocodeReverse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GeocodeReverse(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRoute() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRoute(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Geocode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Geocode() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::GeocodeRequest, ::ric::geo::OsmResponse>(std::bind(&WithStreamedUnaryMethod_Geocode<BaseClass>::StreamedGeocode, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Geocode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Geocode(::grpc::ServerContext* context, const ::ric::geo::GeocodeRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGeocode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::GeocodeRequest,::ric::geo::OsmResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GeocodeReverse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GeocodeReverse() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::GeocodeReverseRequest, ::ric::geo::OsmResponse>(std::bind(&WithStreamedUnaryMethod_GeocodeReverse<BaseClass>::StreamedGeocodeReverse, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GeocodeReverse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GeocodeReverse(::grpc::ServerContext* context, const ::ric::geo::GeocodeReverseRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGeocodeReverse(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::GeocodeReverseRequest,::ric::geo::OsmResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetRoute() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::GetRouteRequest, ::ric::geo::OsmResponse>(std::bind(&WithStreamedUnaryMethod_GetRoute<BaseClass>::StreamedGetRoute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRoute(::grpc::ServerContext* context, const ::ric::geo::GetRouteRequest* request, ::ric::geo::OsmResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRoute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::GetRouteRequest,::ric::geo::OsmResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Geocode<WithStreamedUnaryMethod_GeocodeReverse<WithStreamedUnaryMethod_GetRoute<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Geocode<WithStreamedUnaryMethod_GeocodeReverse<WithStreamedUnaryMethod_GetRoute<Service > > > StreamedService;
};

class Check final {
 public:
  static constexpr char const* service_full_name() {
    return "ric.geo.Check";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status CheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::ric::geo::CheckInResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::CheckInResponse>> AsyncCheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::CheckInResponse>>(AsyncCheckInRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::CheckInResponse>> PrepareAsyncCheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::CheckInResponse>>(PrepareAsyncCheckInRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void CheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::CheckInResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::CheckInResponse>* AsyncCheckInRaw(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ric::geo::CheckInResponse>* PrepareAsyncCheckInRaw(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::ric::geo::CheckInResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::CheckInResponse>> AsyncCheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::CheckInResponse>>(AsyncCheckInRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::CheckInResponse>> PrepareAsyncCheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ric::geo::CheckInResponse>>(PrepareAsyncCheckInRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CheckIn(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response, std::function<void(::grpc::Status)>) override;
      void CheckIn(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::ric::geo::CheckInResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ric::geo::CheckInResponse>* AsyncCheckInRaw(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ric::geo::CheckInResponse>* PrepareAsyncCheckInRaw(::grpc::ClientContext* context, const ::ric::geo::CheckInRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CheckIn_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CheckIn() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CheckIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckIn(::grpc::ServerContext* context, ::ric::geo::CheckInRequest* request, ::grpc::ServerAsyncResponseWriter< ::ric::geo::CheckInResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CheckIn<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CheckIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CheckIn() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::ric::geo::CheckInRequest, ::ric::geo::CheckInResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ric::geo::CheckInRequest* request,
                 ::ric::geo::CheckInResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CheckIn(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_CheckIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_CheckIn<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CheckIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CheckIn() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CheckIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CheckIn() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CheckIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckIn(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CheckIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CheckIn() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CheckIn(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CheckIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CheckIn(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckIn : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CheckIn() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::ric::geo::CheckInRequest, ::ric::geo::CheckInResponse>(std::bind(&WithStreamedUnaryMethod_CheckIn<BaseClass>::StreamedCheckIn, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CheckIn() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckIn(::grpc::ServerContext* context, const ::ric::geo::CheckInRequest* request, ::ric::geo::CheckInResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckIn(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ric::geo::CheckInRequest,::ric::geo::CheckInResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CheckIn<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CheckIn<Service > StreamedService;
};

}  // namespace geo
}  // namespace ric


#endif  // GRPC_ric_2dgeo_2fricgeo_2eproto__INCLUDED
