// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ric-tasks/rictasks.proto

#ifndef PROTOBUF_INCLUDED_ric_2dtasks_2frictasks_2eproto
#define PROTOBUF_INCLUDED_ric_2dtasks_2frictasks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ric_2dtasks_2frictasks_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_ric_2dtasks_2frictasks_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_ric_2dtasks_2frictasks_2eproto();
namespace ric {
namespace tasks {
class ChangeStatusRequest;
class ChangeStatusRequestDefaultTypeInternal;
extern ChangeStatusRequestDefaultTypeInternal _ChangeStatusRequest_default_instance_;
class ChangeStatusResponse;
class ChangeStatusResponseDefaultTypeInternal;
extern ChangeStatusResponseDefaultTypeInternal _ChangeStatusResponse_default_instance_;
class CreateRequest;
class CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateResponse;
class CreateResponseDefaultTypeInternal;
extern CreateResponseDefaultTypeInternal _CreateResponse_default_instance_;
class Deadline;
class DeadlineDefaultTypeInternal;
extern DeadlineDefaultTypeInternal _Deadline_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class IndoorLocation;
class IndoorLocationDefaultTypeInternal;
extern IndoorLocationDefaultTypeInternal _IndoorLocation_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class MasterTask;
class MasterTaskDefaultTypeInternal;
extern MasterTaskDefaultTypeInternal _MasterTask_default_instance_;
class ObjectId;
class ObjectIdDefaultTypeInternal;
extern ObjectIdDefaultTypeInternal _ObjectId_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskId;
class TaskIdDefaultTypeInternal;
extern TaskIdDefaultTypeInternal _TaskId_default_instance_;
class UpdateOrderRequest;
class UpdateOrderRequestDefaultTypeInternal;
extern UpdateOrderRequestDefaultTypeInternal _UpdateOrderRequest_default_instance_;
class UpdateOrderRequest_PositionsEntry_DoNotUse;
class UpdateOrderRequest_PositionsEntry_DoNotUseDefaultTypeInternal;
extern UpdateOrderRequest_PositionsEntry_DoNotUseDefaultTypeInternal _UpdateOrderRequest_PositionsEntry_DoNotUse_default_instance_;
class UpdateOrderResponse;
class UpdateOrderResponseDefaultTypeInternal;
extern UpdateOrderResponseDefaultTypeInternal _UpdateOrderResponse_default_instance_;
class UpdateRequest;
class UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
class UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
}  // namespace tasks
}  // namespace ric
namespace google {
namespace protobuf {
template<> ::ric::tasks::ChangeStatusRequest* Arena::CreateMaybeMessage<::ric::tasks::ChangeStatusRequest>(Arena*);
template<> ::ric::tasks::ChangeStatusResponse* Arena::CreateMaybeMessage<::ric::tasks::ChangeStatusResponse>(Arena*);
template<> ::ric::tasks::CreateRequest* Arena::CreateMaybeMessage<::ric::tasks::CreateRequest>(Arena*);
template<> ::ric::tasks::CreateResponse* Arena::CreateMaybeMessage<::ric::tasks::CreateResponse>(Arena*);
template<> ::ric::tasks::Deadline* Arena::CreateMaybeMessage<::ric::tasks::Deadline>(Arena*);
template<> ::ric::tasks::DeleteRequest* Arena::CreateMaybeMessage<::ric::tasks::DeleteRequest>(Arena*);
template<> ::ric::tasks::DeleteResponse* Arena::CreateMaybeMessage<::ric::tasks::DeleteResponse>(Arena*);
template<> ::ric::tasks::GetRequest* Arena::CreateMaybeMessage<::ric::tasks::GetRequest>(Arena*);
template<> ::ric::tasks::GetResponse* Arena::CreateMaybeMessage<::ric::tasks::GetResponse>(Arena*);
template<> ::ric::tasks::IndoorLocation* Arena::CreateMaybeMessage<::ric::tasks::IndoorLocation>(Arena*);
template<> ::ric::tasks::Location* Arena::CreateMaybeMessage<::ric::tasks::Location>(Arena*);
template<> ::ric::tasks::MasterTask* Arena::CreateMaybeMessage<::ric::tasks::MasterTask>(Arena*);
template<> ::ric::tasks::ObjectId* Arena::CreateMaybeMessage<::ric::tasks::ObjectId>(Arena*);
template<> ::ric::tasks::Task* Arena::CreateMaybeMessage<::ric::tasks::Task>(Arena*);
template<> ::ric::tasks::TaskId* Arena::CreateMaybeMessage<::ric::tasks::TaskId>(Arena*);
template<> ::ric::tasks::UpdateOrderRequest* Arena::CreateMaybeMessage<::ric::tasks::UpdateOrderRequest>(Arena*);
template<> ::ric::tasks::UpdateOrderRequest_PositionsEntry_DoNotUse* Arena::CreateMaybeMessage<::ric::tasks::UpdateOrderRequest_PositionsEntry_DoNotUse>(Arena*);
template<> ::ric::tasks::UpdateOrderResponse* Arena::CreateMaybeMessage<::ric::tasks::UpdateOrderResponse>(Arena*);
template<> ::ric::tasks::UpdateRequest* Arena::CreateMaybeMessage<::ric::tasks::UpdateRequest>(Arena*);
template<> ::ric::tasks::UpdateResponse* Arena::CreateMaybeMessage<::ric::tasks::UpdateResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ric {
namespace tasks {

enum Task_Status {
  Task_Status_INVALID = 0,
  Task_Status_CREATED = 1,
  Task_Status_ASSIGNED = 2,
  Task_Status_IN_WORK = 3,
  Task_Status_CLOSED = 4,
  Task_Status_Task_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Task_Status_Task_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Task_Status_IsValid(int value);
const Task_Status Task_Status_Status_MIN = Task_Status_INVALID;
const Task_Status Task_Status_Status_MAX = Task_Status_CLOSED;
const int Task_Status_Status_ARRAYSIZE = Task_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Task_Status_descriptor();
inline const ::std::string& Task_Status_Name(Task_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Task_Status_descriptor(), value);
}
inline bool Task_Status_Parse(
    const ::std::string& name, Task_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Task_Status>(
    Task_Status_descriptor(), name, value);
}
enum MasterTask_Constrain {
  MasterTask_Constrain_INVALID = 0,
  MasterTask_Constrain_UNORDERED = 1,
  MasterTask_Constrain_ORDERED = 2,
  MasterTask_Constrain_MasterTask_Constrain_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  MasterTask_Constrain_MasterTask_Constrain_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool MasterTask_Constrain_IsValid(int value);
const MasterTask_Constrain MasterTask_Constrain_Constrain_MIN = MasterTask_Constrain_INVALID;
const MasterTask_Constrain MasterTask_Constrain_Constrain_MAX = MasterTask_Constrain_ORDERED;
const int MasterTask_Constrain_Constrain_ARRAYSIZE = MasterTask_Constrain_Constrain_MAX + 1;

const ::google::protobuf::EnumDescriptor* MasterTask_Constrain_descriptor();
inline const ::std::string& MasterTask_Constrain_Name(MasterTask_Constrain value) {
  return ::google::protobuf::internal::NameOfEnum(
    MasterTask_Constrain_descriptor(), value);
}
inline bool MasterTask_Constrain_Parse(
    const ::std::string& name, MasterTask_Constrain* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MasterTask_Constrain>(
    MasterTask_Constrain_descriptor(), name, value);
}
enum MasterTask_Priority {
  MasterTask_Priority_UNDEFINED = 0,
  MasterTask_Priority_LOW = 1,
  MasterTask_Priority_NORMAL = 2,
  MasterTask_Priority_HIGH = 3,
  MasterTask_Priority_MasterTask_Priority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  MasterTask_Priority_MasterTask_Priority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool MasterTask_Priority_IsValid(int value);
const MasterTask_Priority MasterTask_Priority_Priority_MIN = MasterTask_Priority_UNDEFINED;
const MasterTask_Priority MasterTask_Priority_Priority_MAX = MasterTask_Priority_HIGH;
const int MasterTask_Priority_Priority_ARRAYSIZE = MasterTask_Priority_Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* MasterTask_Priority_descriptor();
inline const ::std::string& MasterTask_Priority_Name(MasterTask_Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    MasterTask_Priority_descriptor(), value);
}
inline bool MasterTask_Priority_Parse(
    const ::std::string& name, MasterTask_Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MasterTask_Priority>(
    MasterTask_Priority_descriptor(), name, value);
}
// ===================================================================

class ObjectId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.ObjectId) */ {
 public:
  ObjectId();
  virtual ~ObjectId();

  ObjectId(const ObjectId& from);

  inline ObjectId& operator=(const ObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectId(ObjectId&& from) noexcept
    : ObjectId() {
    *this = ::std::move(from);
  }

  inline ObjectId& operator=(ObjectId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectId* internal_default_instance() {
    return reinterpret_cast<const ObjectId*>(
               &_ObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ObjectId* other);
  friend void swap(ObjectId& a, ObjectId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectId* New() const final {
    return CreateMaybeMessage<ObjectId>(nullptr);
  }

  ObjectId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectId& from);
  void MergeFrom(const ObjectId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:ric.tasks.ObjectId)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class TaskId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.TaskId) */ {
 public:
  TaskId();
  virtual ~TaskId();

  TaskId(const TaskId& from);

  inline TaskId& operator=(const TaskId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskId(TaskId&& from) noexcept
    : TaskId() {
    *this = ::std::move(from);
  }

  inline TaskId& operator=(TaskId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskId* internal_default_instance() {
    return reinterpret_cast<const TaskId*>(
               &_TaskId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TaskId* other);
  friend void swap(TaskId& a, TaskId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskId* New() const final {
    return CreateMaybeMessage<TaskId>(nullptr);
  }

  TaskId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskId& from);
  void MergeFrom(const TaskId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:ric.tasks.TaskId)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(nullptr);
  }

  Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 4;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // .ric.tasks.IndoorLocation indoor = 5;
  bool has_indoor() const;
  void clear_indoor();
  static const int kIndoorFieldNumber = 5;
  const ::ric::tasks::IndoorLocation& indoor() const;
  ::ric::tasks::IndoorLocation* release_indoor();
  ::ric::tasks::IndoorLocation* mutable_indoor();
  void set_allocated_indoor(::ric::tasks::IndoorLocation* indoor);

  // double lat = 1;
  void clear_lat();
  static const int kLatFieldNumber = 1;
  double lat() const;
  void set_lat(double value);

  // double lng = 2;
  void clear_lng();
  static const int kLngFieldNumber = 2;
  double lng() const;
  void set_lng(double value);

  // double radius = 3;
  void clear_radius();
  static const int kRadiusFieldNumber = 3;
  double radius() const;
  void set_radius(double value);

  // @@protoc_insertion_point(class_scope:ric.tasks.Location)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::ric::tasks::IndoorLocation* indoor_;
  double lat_;
  double lng_;
  double radius_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class IndoorLocation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.IndoorLocation) */ {
 public:
  IndoorLocation();
  virtual ~IndoorLocation();

  IndoorLocation(const IndoorLocation& from);

  inline IndoorLocation& operator=(const IndoorLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndoorLocation(IndoorLocation&& from) noexcept
    : IndoorLocation() {
    *this = ::std::move(from);
  }

  inline IndoorLocation& operator=(IndoorLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IndoorLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndoorLocation* internal_default_instance() {
    return reinterpret_cast<const IndoorLocation*>(
               &_IndoorLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(IndoorLocation* other);
  friend void swap(IndoorLocation& a, IndoorLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndoorLocation* New() const final {
    return CreateMaybeMessage<IndoorLocation>(nullptr);
  }

  IndoorLocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndoorLocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndoorLocation& from);
  void MergeFrom(const IndoorLocation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndoorLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double radius = 4;
  void clear_radius();
  static const int kRadiusFieldNumber = 4;
  double radius() const;
  void set_radius(double value);

  // @@protoc_insertion_point(class_scope:ric.tasks.IndoorLocation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  double radius_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.Task) */ {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Task* other);
  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return CreateMaybeMessage<Task>(nullptr);
  }

  Task* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Task_Status Status;
  static const Status INVALID =
    Task_Status_INVALID;
  static const Status CREATED =
    Task_Status_CREATED;
  static const Status ASSIGNED =
    Task_Status_ASSIGNED;
  static const Status IN_WORK =
    Task_Status_IN_WORK;
  static const Status CLOSED =
    Task_Status_CLOSED;
  static inline bool Status_IsValid(int value) {
    return Task_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Task_Status_Status_MIN;
  static const Status Status_MAX =
    Task_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Task_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Task_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Task_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Task_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ric.tasks.Deadline deadlines = 10;
  int deadlines_size() const;
  void clear_deadlines();
  static const int kDeadlinesFieldNumber = 10;
  ::ric::tasks::Deadline* mutable_deadlines(int index);
  ::google::protobuf::RepeatedPtrField< ::ric::tasks::Deadline >*
      mutable_deadlines();
  const ::ric::tasks::Deadline& deadlines(int index) const;
  ::ric::tasks::Deadline* add_deadlines();
  const ::google::protobuf::RepeatedPtrField< ::ric::tasks::Deadline >&
      deadlines() const;

  // repeated string files = 14;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 14;
  const ::std::string& files(int index) const;
  ::std::string* mutable_files(int index);
  void set_files(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_files(int index, ::std::string&& value);
  #endif
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  ::std::string* add_files();
  void add_files(const ::std::string& value);
  #if LANG_CXX11
  void add_files(::std::string&& value);
  #endif
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& files() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_files();

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string kind = 3;
  void clear_kind();
  static const int kKindFieldNumber = 3;
  const ::std::string& kind() const;
  void set_kind(const ::std::string& value);
  #if LANG_CXX11
  void set_kind(::std::string&& value);
  #endif
  void set_kind(const char* value);
  void set_kind(const char* value, size_t size);
  ::std::string* mutable_kind();
  ::std::string* release_kind();
  void set_allocated_kind(::std::string* kind);

  // string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string comment = 13;
  void clear_comment();
  static const int kCommentFieldNumber = 13;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // .ric.tasks.TaskId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::ric::tasks::TaskId& id() const;
  ::ric::tasks::TaskId* release_id();
  ::ric::tasks::TaskId* mutable_id();
  void set_allocated_id(::ric::tasks::TaskId* id);

  // .ric.tasks.ObjectId object = 6;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 6;
  const ::ric::tasks::ObjectId& object() const;
  ::ric::tasks::ObjectId* release_object();
  ::ric::tasks::ObjectId* mutable_object();
  void set_allocated_object(::ric::tasks::ObjectId* object);

  // .ric.tasks.Location begin = 7;
  bool has_begin() const;
  void clear_begin();
  static const int kBeginFieldNumber = 7;
  const ::ric::tasks::Location& begin() const;
  ::ric::tasks::Location* release_begin();
  ::ric::tasks::Location* mutable_begin();
  void set_allocated_begin(::ric::tasks::Location* begin);

  // .ric.tasks.Location end = 8;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 8;
  const ::ric::tasks::Location& end() const;
  ::ric::tasks::Location* release_end();
  ::ric::tasks::Location* mutable_end();
  void set_allocated_end(::ric::tasks::Location* end);

  // .ric.tasks.ObjectId owner = 11;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 11;
  const ::ric::tasks::ObjectId& owner() const;
  ::ric::tasks::ObjectId* release_owner();
  ::ric::tasks::ObjectId* mutable_owner();
  void set_allocated_owner(::ric::tasks::ObjectId* owner);

  // .google.protobuf.BoolValue success = 12;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 12;
  const ::google::protobuf::BoolValue& success() const;
  ::google::protobuf::BoolValue* release_success();
  ::google::protobuf::BoolValue* mutable_success();
  void set_allocated_success(::google::protobuf::BoolValue* success);

  // int64 created_at = 9;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 9;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // .ric.tasks.Task.Status status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::ric::tasks::Task_Status status() const;
  void set_status(::ric::tasks::Task_Status value);

  // @@protoc_insertion_point(class_scope:ric.tasks.Task)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ric::tasks::Deadline > deadlines_;
  ::google::protobuf::RepeatedPtrField<::std::string> files_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr kind_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::ric::tasks::TaskId* id_;
  ::ric::tasks::ObjectId* object_;
  ::ric::tasks::Location* begin_;
  ::ric::tasks::Location* end_;
  ::ric::tasks::ObjectId* owner_;
  ::google::protobuf::BoolValue* success_;
  ::google::protobuf::int64 created_at_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class Deadline final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.Deadline) */ {
 public:
  Deadline();
  virtual ~Deadline();

  Deadline(const Deadline& from);

  inline Deadline& operator=(const Deadline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Deadline(Deadline&& from) noexcept
    : Deadline() {
    *this = ::std::move(from);
  }

  inline Deadline& operator=(Deadline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Deadline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Deadline* internal_default_instance() {
    return reinterpret_cast<const Deadline*>(
               &_Deadline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Deadline* other);
  friend void swap(Deadline& a, Deadline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Deadline* New() const final {
    return CreateMaybeMessage<Deadline>(nullptr);
  }

  Deadline* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Deadline>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Deadline& from);
  void MergeFrom(const Deadline& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Deadline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value notify_until = 2;
  bool has_notify_until() const;
  void clear_notify_until();
  static const int kNotifyUntilFieldNumber = 2;
  const ::google::protobuf::Int64Value& notify_until() const;
  ::google::protobuf::Int64Value* release_notify_until();
  ::google::protobuf::Int64Value* mutable_notify_until();
  void set_allocated_notify_until(::google::protobuf::Int64Value* notify_until);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .ric.tasks.Task.Status status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::ric::tasks::Task_Status status() const;
  void set_status(::ric::tasks::Task_Status value);

  // @@protoc_insertion_point(class_scope:ric.tasks.Deadline)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int64Value* notify_until_;
  ::google::protobuf::int64 timestamp_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class MasterTask final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.MasterTask) */ {
 public:
  MasterTask();
  virtual ~MasterTask();

  MasterTask(const MasterTask& from);

  inline MasterTask& operator=(const MasterTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterTask(MasterTask&& from) noexcept
    : MasterTask() {
    *this = ::std::move(from);
  }

  inline MasterTask& operator=(MasterTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MasterTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterTask* internal_default_instance() {
    return reinterpret_cast<const MasterTask*>(
               &_MasterTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MasterTask* other);
  friend void swap(MasterTask& a, MasterTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterTask* New() const final {
    return CreateMaybeMessage<MasterTask>(nullptr);
  }

  MasterTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MasterTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MasterTask& from);
  void MergeFrom(const MasterTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MasterTask_Constrain Constrain;
  static const Constrain INVALID =
    MasterTask_Constrain_INVALID;
  static const Constrain UNORDERED =
    MasterTask_Constrain_UNORDERED;
  static const Constrain ORDERED =
    MasterTask_Constrain_ORDERED;
  static inline bool Constrain_IsValid(int value) {
    return MasterTask_Constrain_IsValid(value);
  }
  static const Constrain Constrain_MIN =
    MasterTask_Constrain_Constrain_MIN;
  static const Constrain Constrain_MAX =
    MasterTask_Constrain_Constrain_MAX;
  static const int Constrain_ARRAYSIZE =
    MasterTask_Constrain_Constrain_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Constrain_descriptor() {
    return MasterTask_Constrain_descriptor();
  }
  static inline const ::std::string& Constrain_Name(Constrain value) {
    return MasterTask_Constrain_Name(value);
  }
  static inline bool Constrain_Parse(const ::std::string& name,
      Constrain* value) {
    return MasterTask_Constrain_Parse(name, value);
  }

  typedef MasterTask_Priority Priority;
  static const Priority UNDEFINED =
    MasterTask_Priority_UNDEFINED;
  static const Priority LOW =
    MasterTask_Priority_LOW;
  static const Priority NORMAL =
    MasterTask_Priority_NORMAL;
  static const Priority HIGH =
    MasterTask_Priority_HIGH;
  static inline bool Priority_IsValid(int value) {
    return MasterTask_Priority_IsValid(value);
  }
  static const Priority Priority_MIN =
    MasterTask_Priority_Priority_MIN;
  static const Priority Priority_MAX =
    MasterTask_Priority_Priority_MAX;
  static const int Priority_ARRAYSIZE =
    MasterTask_Priority_Priority_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Priority_descriptor() {
    return MasterTask_Priority_descriptor();
  }
  static inline const ::std::string& Priority_Name(Priority value) {
    return MasterTask_Priority_Name(value);
  }
  static inline bool Priority_Parse(const ::std::string& name,
      Priority* value) {
    return MasterTask_Priority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ric.tasks.Task subtasks = 4;
  int subtasks_size() const;
  void clear_subtasks();
  static const int kSubtasksFieldNumber = 4;
  ::ric::tasks::Task* mutable_subtasks(int index);
  ::google::protobuf::RepeatedPtrField< ::ric::tasks::Task >*
      mutable_subtasks();
  const ::ric::tasks::Task& subtasks(int index) const;
  ::ric::tasks::Task* add_subtasks();
  const ::google::protobuf::RepeatedPtrField< ::ric::tasks::Task >&
      subtasks() const;

  // repeated string tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tags();

  // .ric.tasks.ObjectId oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::ric::tasks::ObjectId& oid() const;
  ::ric::tasks::ObjectId* release_oid();
  ::ric::tasks::ObjectId* mutable_oid();
  void set_allocated_oid(::ric::tasks::ObjectId* oid);

  // .ric.tasks.ObjectId owner = 2;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 2;
  const ::ric::tasks::ObjectId& owner() const;
  ::ric::tasks::ObjectId* release_owner();
  ::ric::tasks::ObjectId* mutable_owner();
  void set_allocated_owner(::ric::tasks::ObjectId* owner);

  // .ric.tasks.ObjectId group = 3;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 3;
  const ::ric::tasks::ObjectId& group() const;
  ::ric::tasks::ObjectId* release_group();
  ::ric::tasks::ObjectId* mutable_group();
  void set_allocated_group(::ric::tasks::ObjectId* group);

  // .ric.tasks.ObjectId assignee = 7;
  bool has_assignee() const;
  void clear_assignee();
  static const int kAssigneeFieldNumber = 7;
  const ::ric::tasks::ObjectId& assignee() const;
  ::ric::tasks::ObjectId* release_assignee();
  ::ric::tasks::ObjectId* mutable_assignee();
  void set_allocated_assignee(::ric::tasks::ObjectId* assignee);

  // .ric.tasks.ObjectId object = 10;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 10;
  const ::ric::tasks::ObjectId& object() const;
  ::ric::tasks::ObjectId* release_object();
  ::ric::tasks::ObjectId* mutable_object();
  void set_allocated_object(::ric::tasks::ObjectId* object);

  // .ric.tasks.MasterTask.Constrain constrain = 5;
  void clear_constrain();
  static const int kConstrainFieldNumber = 5;
  ::ric::tasks::MasterTask_Constrain constrain() const;
  void set_constrain(::ric::tasks::MasterTask_Constrain value);

  // .ric.tasks.MasterTask.Priority priority = 8;
  void clear_priority();
  static const int kPriorityFieldNumber = 8;
  ::ric::tasks::MasterTask_Priority priority() const;
  void set_priority(::ric::tasks::MasterTask_Priority value);

  // int64 time = 9;
  void clear_time();
  static const int kTimeFieldNumber = 9;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ric.tasks.MasterTask)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ric::tasks::Task > subtasks_;
  ::google::protobuf::RepeatedPtrField<::std::string> tags_;
  ::ric::tasks::ObjectId* oid_;
  ::ric::tasks::ObjectId* owner_;
  ::ric::tasks::ObjectId* group_;
  ::ric::tasks::ObjectId* assignee_;
  ::ric::tasks::ObjectId* object_;
  int constrain_;
  int priority_;
  ::google::protobuf::int64 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.CreateRequest) */ {
 public:
  CreateRequest();
  virtual ~CreateRequest();

  CreateRequest(const CreateRequest& from);

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CreateRequest* other);
  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRequest* New() const final {
    return CreateMaybeMessage<CreateRequest>(nullptr);
  }

  CreateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateRequest& from);
  void MergeFrom(const CreateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.tasks.MasterTask master_task = 1;
  bool has_master_task() const;
  void clear_master_task();
  static const int kMasterTaskFieldNumber = 1;
  const ::ric::tasks::MasterTask& master_task() const;
  ::ric::tasks::MasterTask* release_master_task();
  ::ric::tasks::MasterTask* mutable_master_task();
  void set_allocated_master_task(::ric::tasks::MasterTask* master_task);

  // @@protoc_insertion_point(class_scope:ric.tasks.CreateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ric::tasks::MasterTask* master_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class CreateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.CreateResponse) */ {
 public:
  CreateResponse();
  virtual ~CreateResponse();

  CreateResponse(const CreateResponse& from);

  inline CreateResponse& operator=(const CreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateResponse(CreateResponse&& from) noexcept
    : CreateResponse() {
    *this = ::std::move(from);
  }

  inline CreateResponse& operator=(CreateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateResponse* internal_default_instance() {
    return reinterpret_cast<const CreateResponse*>(
               &_CreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CreateResponse* other);
  friend void swap(CreateResponse& a, CreateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateResponse* New() const final {
    return CreateMaybeMessage<CreateResponse>(nullptr);
  }

  CreateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateResponse& from);
  void MergeFrom(const CreateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ric.tasks.TaskId sub_ids = 2;
  int sub_ids_size() const;
  void clear_sub_ids();
  static const int kSubIdsFieldNumber = 2;
  ::ric::tasks::TaskId* mutable_sub_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::ric::tasks::TaskId >*
      mutable_sub_ids();
  const ::ric::tasks::TaskId& sub_ids(int index) const;
  ::ric::tasks::TaskId* add_sub_ids();
  const ::google::protobuf::RepeatedPtrField< ::ric::tasks::TaskId >&
      sub_ids() const;

  // .ric.tasks.ObjectId oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::ric::tasks::ObjectId& oid() const;
  ::ric::tasks::ObjectId* release_oid();
  ::ric::tasks::ObjectId* mutable_oid();
  void set_allocated_oid(::ric::tasks::ObjectId* oid);

  // @@protoc_insertion_point(class_scope:ric.tasks.CreateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ric::tasks::TaskId > sub_ids_;
  ::ric::tasks::ObjectId* oid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetRequest& default_instance();

  enum PayloadCase {
    kOid = 1,
    kTid = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetRequest* other);
  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(nullptr);
  }

  GetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.tasks.ObjectId oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::ric::tasks::ObjectId& oid() const;
  ::ric::tasks::ObjectId* release_oid();
  ::ric::tasks::ObjectId* mutable_oid();
  void set_allocated_oid(::ric::tasks::ObjectId* oid);

  // .ric.tasks.TaskId tid = 2;
  bool has_tid() const;
  void clear_tid();
  static const int kTidFieldNumber = 2;
  const ::ric::tasks::TaskId& tid() const;
  ::ric::tasks::TaskId* release_tid();
  ::ric::tasks::TaskId* mutable_tid();
  void set_allocated_tid(::ric::tasks::TaskId* tid);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ric.tasks.GetRequest)
 private:
  class HasBitSetters;
  void set_has_oid();
  void set_has_tid();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::ric::tasks::ObjectId* oid_;
    ::ric::tasks::TaskId* tid_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetResponse* other);
  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(nullptr);
  }

  GetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.tasks.MasterTask master_task = 1;
  bool has_master_task() const;
  void clear_master_task();
  static const int kMasterTaskFieldNumber = 1;
  const ::ric::tasks::MasterTask& master_task() const;
  ::ric::tasks::MasterTask* release_master_task();
  ::ric::tasks::MasterTask* mutable_master_task();
  void set_allocated_master_task(::ric::tasks::MasterTask* master_task);

  // @@protoc_insertion_point(class_scope:ric.tasks.GetResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ric::tasks::MasterTask* master_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteRequest& default_instance();

  enum PayloadCase {
    kOid = 1,
    kTid = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(nullptr);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.tasks.ObjectId oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::ric::tasks::ObjectId& oid() const;
  ::ric::tasks::ObjectId* release_oid();
  ::ric::tasks::ObjectId* mutable_oid();
  void set_allocated_oid(::ric::tasks::ObjectId* oid);

  // .ric.tasks.TaskId tid = 2;
  bool has_tid() const;
  void clear_tid();
  static const int kTidFieldNumber = 2;
  const ::ric::tasks::TaskId& tid() const;
  ::ric::tasks::TaskId* release_tid();
  ::ric::tasks::TaskId* mutable_tid();
  void set_allocated_tid(::ric::tasks::TaskId* tid);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ric.tasks.DeleteRequest)
 private:
  class HasBitSetters;
  void set_has_oid();
  void set_has_tid();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::ric::tasks::ObjectId* oid_;
    ::ric::tasks::TaskId* tid_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return CreateMaybeMessage<DeleteResponse>(nullptr);
  }

  DeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.tasks.DeleteResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.UpdateRequest) */ {
 public:
  UpdateRequest();
  virtual ~UpdateRequest();

  UpdateRequest(const UpdateRequest& from);

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(UpdateRequest* other);
  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRequest* New() const final {
    return CreateMaybeMessage<UpdateRequest>(nullptr);
  }

  UpdateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateRequest& from);
  void MergeFrom(const UpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.tasks.MasterTask master_task = 1;
  bool has_master_task() const;
  void clear_master_task();
  static const int kMasterTaskFieldNumber = 1;
  const ::ric::tasks::MasterTask& master_task() const;
  ::ric::tasks::MasterTask* release_master_task();
  ::ric::tasks::MasterTask* mutable_master_task();
  void set_allocated_master_task(::ric::tasks::MasterTask* master_task);

  // @@protoc_insertion_point(class_scope:ric.tasks.UpdateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ric::tasks::MasterTask* master_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class UpdateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.UpdateResponse) */ {
 public:
  UpdateResponse();
  virtual ~UpdateResponse();

  UpdateResponse(const UpdateResponse& from);

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(UpdateResponse* other);
  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateResponse* New() const final {
    return CreateMaybeMessage<UpdateResponse>(nullptr);
  }

  UpdateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateResponse& from);
  void MergeFrom(const UpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ric.tasks.MasterTask master_task = 1;
  bool has_master_task() const;
  void clear_master_task();
  static const int kMasterTaskFieldNumber = 1;
  const ::ric::tasks::MasterTask& master_task() const;
  ::ric::tasks::MasterTask* release_master_task();
  ::ric::tasks::MasterTask* mutable_master_task();
  void set_allocated_master_task(::ric::tasks::MasterTask* master_task);

  // @@protoc_insertion_point(class_scope:ric.tasks.UpdateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ric::tasks::MasterTask* master_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrderRequest_PositionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<UpdateOrderRequest_PositionsEntry_DoNotUse, 
    ::google::protobuf::int32, ::ric::tasks::TaskId,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<UpdateOrderRequest_PositionsEntry_DoNotUse, 
    ::google::protobuf::int32, ::ric::tasks::TaskId,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  UpdateOrderRequest_PositionsEntry_DoNotUse();
  UpdateOrderRequest_PositionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const UpdateOrderRequest_PositionsEntry_DoNotUse& other);
  static const UpdateOrderRequest_PositionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateOrderRequest_PositionsEntry_DoNotUse*>(&_UpdateOrderRequest_PositionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class UpdateOrderRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.UpdateOrderRequest) */ {
 public:
  UpdateOrderRequest();
  virtual ~UpdateOrderRequest();

  UpdateOrderRequest(const UpdateOrderRequest& from);

  inline UpdateOrderRequest& operator=(const UpdateOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateOrderRequest(UpdateOrderRequest&& from) noexcept
    : UpdateOrderRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrderRequest& operator=(UpdateOrderRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateOrderRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateOrderRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrderRequest*>(
               &_UpdateOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(UpdateOrderRequest* other);
  friend void swap(UpdateOrderRequest& a, UpdateOrderRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateOrderRequest* New() const final {
    return CreateMaybeMessage<UpdateOrderRequest>(nullptr);
  }

  UpdateOrderRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateOrderRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateOrderRequest& from);
  void MergeFrom(const UpdateOrderRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrderRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .ric.tasks.TaskId> positions = 2;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::ric::tasks::TaskId >&
      positions() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::ric::tasks::TaskId >*
      mutable_positions();

  // .ric.tasks.ObjectId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::ric::tasks::ObjectId& id() const;
  ::ric::tasks::ObjectId* release_id();
  ::ric::tasks::ObjectId* mutable_id();
  void set_allocated_id(::ric::tasks::ObjectId* id);

  // @@protoc_insertion_point(class_scope:ric.tasks.UpdateOrderRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      UpdateOrderRequest_PositionsEntry_DoNotUse,
      ::google::protobuf::int32, ::ric::tasks::TaskId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > positions_;
  ::ric::tasks::ObjectId* id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrderResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.UpdateOrderResponse) */ {
 public:
  UpdateOrderResponse();
  virtual ~UpdateOrderResponse();

  UpdateOrderResponse(const UpdateOrderResponse& from);

  inline UpdateOrderResponse& operator=(const UpdateOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateOrderResponse(UpdateOrderResponse&& from) noexcept
    : UpdateOrderResponse() {
    *this = ::std::move(from);
  }

  inline UpdateOrderResponse& operator=(UpdateOrderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateOrderResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateOrderResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateOrderResponse*>(
               &_UpdateOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(UpdateOrderResponse* other);
  friend void swap(UpdateOrderResponse& a, UpdateOrderResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateOrderResponse* New() const final {
    return CreateMaybeMessage<UpdateOrderResponse>(nullptr);
  }

  UpdateOrderResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateOrderResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateOrderResponse& from);
  void MergeFrom(const UpdateOrderResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrderResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.tasks.UpdateOrderResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class ChangeStatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.ChangeStatusRequest) */ {
 public:
  ChangeStatusRequest();
  virtual ~ChangeStatusRequest();

  ChangeStatusRequest(const ChangeStatusRequest& from);

  inline ChangeStatusRequest& operator=(const ChangeStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeStatusRequest(ChangeStatusRequest&& from) noexcept
    : ChangeStatusRequest() {
    *this = ::std::move(from);
  }

  inline ChangeStatusRequest& operator=(ChangeStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangeStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusRequest*>(
               &_ChangeStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ChangeStatusRequest* other);
  friend void swap(ChangeStatusRequest& a, ChangeStatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusRequest* New() const final {
    return CreateMaybeMessage<ChangeStatusRequest>(nullptr);
  }

  ChangeStatusRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeStatusRequest& from);
  void MergeFrom(const ChangeStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string files = 6;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 6;
  const ::std::string& files(int index) const;
  ::std::string* mutable_files(int index);
  void set_files(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_files(int index, ::std::string&& value);
  #endif
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  ::std::string* add_files();
  void add_files(const ::std::string& value);
  #if LANG_CXX11
  void add_files(::std::string&& value);
  #endif
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& files() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_files();

  // string comment = 5;
  void clear_comment();
  static const int kCommentFieldNumber = 5;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // .ric.tasks.TaskId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::ric::tasks::TaskId& id() const;
  ::ric::tasks::TaskId* release_id();
  ::ric::tasks::TaskId* mutable_id();
  void set_allocated_id(::ric::tasks::TaskId* id);

  // .ric.tasks.Location location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::ric::tasks::Location& location() const;
  ::ric::tasks::Location* release_location();
  ::ric::tasks::Location* mutable_location();
  void set_allocated_location(::ric::tasks::Location* location);

  // .google.protobuf.BoolValue success = 4;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 4;
  const ::google::protobuf::BoolValue& success() const;
  ::google::protobuf::BoolValue* release_success();
  ::google::protobuf::BoolValue* mutable_success();
  void set_allocated_success(::google::protobuf::BoolValue* success);

  // .ric.tasks.Task.Status new_status = 2;
  void clear_new_status();
  static const int kNewStatusFieldNumber = 2;
  ::ric::tasks::Task_Status new_status() const;
  void set_new_status(::ric::tasks::Task_Status value);

  // @@protoc_insertion_point(class_scope:ric.tasks.ChangeStatusRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> files_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::ric::tasks::TaskId* id_;
  ::ric::tasks::Location* location_;
  ::google::protobuf::BoolValue* success_;
  int new_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// -------------------------------------------------------------------

class ChangeStatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ric.tasks.ChangeStatusResponse) */ {
 public:
  ChangeStatusResponse();
  virtual ~ChangeStatusResponse();

  ChangeStatusResponse(const ChangeStatusResponse& from);

  inline ChangeStatusResponse& operator=(const ChangeStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeStatusResponse(ChangeStatusResponse&& from) noexcept
    : ChangeStatusResponse() {
    *this = ::std::move(from);
  }

  inline ChangeStatusResponse& operator=(ChangeStatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangeStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusResponse*>(
               &_ChangeStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ChangeStatusResponse* other);
  friend void swap(ChangeStatusResponse& a, ChangeStatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusResponse* New() const final {
    return CreateMaybeMessage<ChangeStatusResponse>(nullptr);
  }

  ChangeStatusResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeStatusResponse& from);
  void MergeFrom(const ChangeStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ric.tasks.ChangeStatusResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ric_2dtasks_2frictasks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObjectId

// string id = 1;
inline void ObjectId::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ObjectId::id() const {
  // @@protoc_insertion_point(field_get:ric.tasks.ObjectId.id)
  return id_.GetNoArena();
}
inline void ObjectId::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.ObjectId.id)
}
#if LANG_CXX11
inline void ObjectId::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.ObjectId.id)
}
#endif
inline void ObjectId::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.ObjectId.id)
}
inline void ObjectId::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.ObjectId.id)
}
inline ::std::string* ObjectId::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.ObjectId.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectId::release_id() {
  // @@protoc_insertion_point(field_release:ric.tasks.ObjectId.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectId::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.ObjectId.id)
}

// -------------------------------------------------------------------

// TaskId

// string id = 1;
inline void TaskId::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskId::id() const {
  // @@protoc_insertion_point(field_get:ric.tasks.TaskId.id)
  return id_.GetNoArena();
}
inline void TaskId::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.TaskId.id)
}
#if LANG_CXX11
inline void TaskId::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.TaskId.id)
}
#endif
inline void TaskId::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.TaskId.id)
}
inline void TaskId::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.TaskId.id)
}
inline ::std::string* TaskId::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.TaskId.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskId::release_id() {
  // @@protoc_insertion_point(field_release:ric.tasks.TaskId.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskId::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.TaskId.id)
}

// -------------------------------------------------------------------

// Location

// double lat = 1;
inline void Location::clear_lat() {
  lat_ = 0;
}
inline double Location::lat() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Location.lat)
  return lat_;
}
inline void Location::set_lat(double value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Location.lat)
}

// double lng = 2;
inline void Location::clear_lng() {
  lng_ = 0;
}
inline double Location::lng() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Location.lng)
  return lng_;
}
inline void Location::set_lng(double value) {
  
  lng_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Location.lng)
}

// double radius = 3;
inline void Location::clear_radius() {
  radius_ = 0;
}
inline double Location::radius() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Location.radius)
  return radius_;
}
inline void Location::set_radius(double value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Location.radius)
}

// string address = 4;
inline void Location::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::address() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Location.address)
  return address_.GetNoArena();
}
inline void Location::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.Location.address)
}
#if LANG_CXX11
inline void Location::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.Location.address)
}
#endif
inline void Location::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.Location.address)
}
inline void Location::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.Location.address)
}
inline ::std::string* Location::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.Location.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_address() {
  // @@protoc_insertion_point(field_release:ric.tasks.Location.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Location.address)
}

// .ric.tasks.IndoorLocation indoor = 5;
inline bool Location::has_indoor() const {
  return this != internal_default_instance() && indoor_ != nullptr;
}
inline void Location::clear_indoor() {
  if (GetArenaNoVirtual() == nullptr && indoor_ != nullptr) {
    delete indoor_;
  }
  indoor_ = nullptr;
}
inline const ::ric::tasks::IndoorLocation& Location::indoor() const {
  const ::ric::tasks::IndoorLocation* p = indoor_;
  // @@protoc_insertion_point(field_get:ric.tasks.Location.indoor)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::IndoorLocation*>(
      &::ric::tasks::_IndoorLocation_default_instance_);
}
inline ::ric::tasks::IndoorLocation* Location::release_indoor() {
  // @@protoc_insertion_point(field_release:ric.tasks.Location.indoor)
  
  ::ric::tasks::IndoorLocation* temp = indoor_;
  indoor_ = nullptr;
  return temp;
}
inline ::ric::tasks::IndoorLocation* Location::mutable_indoor() {
  
  if (indoor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::IndoorLocation>(GetArenaNoVirtual());
    indoor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Location.indoor)
  return indoor_;
}
inline void Location::set_allocated_indoor(::ric::tasks::IndoorLocation* indoor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete indoor_;
  }
  if (indoor) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      indoor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, indoor, submessage_arena);
    }
    
  } else {
    
  }
  indoor_ = indoor;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Location.indoor)
}

// -------------------------------------------------------------------

// IndoorLocation

// double x = 1;
inline void IndoorLocation::clear_x() {
  x_ = 0;
}
inline double IndoorLocation::x() const {
  // @@protoc_insertion_point(field_get:ric.tasks.IndoorLocation.x)
  return x_;
}
inline void IndoorLocation::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.IndoorLocation.x)
}

// double y = 2;
inline void IndoorLocation::clear_y() {
  y_ = 0;
}
inline double IndoorLocation::y() const {
  // @@protoc_insertion_point(field_get:ric.tasks.IndoorLocation.y)
  return y_;
}
inline void IndoorLocation::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.IndoorLocation.y)
}

// double z = 3;
inline void IndoorLocation::clear_z() {
  z_ = 0;
}
inline double IndoorLocation::z() const {
  // @@protoc_insertion_point(field_get:ric.tasks.IndoorLocation.z)
  return z_;
}
inline void IndoorLocation::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.IndoorLocation.z)
}

// double radius = 4;
inline void IndoorLocation::clear_radius() {
  radius_ = 0;
}
inline double IndoorLocation::radius() const {
  // @@protoc_insertion_point(field_get:ric.tasks.IndoorLocation.radius)
  return radius_;
}
inline void IndoorLocation::set_radius(double value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.IndoorLocation.radius)
}

// -------------------------------------------------------------------

// Task

// .ric.tasks.TaskId id = 1;
inline bool Task::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline void Task::clear_id() {
  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::ric::tasks::TaskId& Task::id() const {
  const ::ric::tasks::TaskId* p = id_;
  // @@protoc_insertion_point(field_get:ric.tasks.Task.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::TaskId*>(
      &::ric::tasks::_TaskId_default_instance_);
}
inline ::ric::tasks::TaskId* Task::release_id() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.id)
  
  ::ric::tasks::TaskId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::ric::tasks::TaskId* Task::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::TaskId>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.id)
  return id_;
}
inline void Task::set_allocated_id(::ric::tasks::TaskId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.id)
}

// string name = 2;
inline void Task::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.name)
  return name_.GetNoArena();
}
inline void Task::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.Task.name)
}
#if LANG_CXX11
inline void Task::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.Task.name)
}
#endif
inline void Task::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.Task.name)
}
inline void Task::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.Task.name)
}
inline ::std::string* Task::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.name)
}

// string kind = 3;
inline void Task::clear_kind() {
  kind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Task::kind() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.kind)
  return kind_.GetNoArena();
}
inline void Task::set_kind(const ::std::string& value) {
  
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.Task.kind)
}
#if LANG_CXX11
inline void Task::set_kind(::std::string&& value) {
  
  kind_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.Task.kind)
}
#endif
inline void Task::set_kind(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.Task.kind)
}
inline void Task::set_kind(const char* value, size_t size) {
  
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.Task.kind)
}
inline ::std::string* Task::mutable_kind() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.kind)
  return kind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_kind() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.kind)
  
  return kind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_kind(::std::string* kind) {
  if (kind != nullptr) {
    
  } else {
    
  }
  kind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kind);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.kind)
}

// string description = 4;
inline void Task::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Task::description() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.description)
  return description_.GetNoArena();
}
inline void Task::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.Task.description)
}
#if LANG_CXX11
inline void Task::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.Task.description)
}
#endif
inline void Task::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.Task.description)
}
inline void Task::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.Task.description)
}
inline ::std::string* Task::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_description() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_description(::std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.description)
}

// .ric.tasks.Task.Status status = 5;
inline void Task::clear_status() {
  status_ = 0;
}
inline ::ric::tasks::Task_Status Task::status() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.status)
  return static_cast< ::ric::tasks::Task_Status >(status_);
}
inline void Task::set_status(::ric::tasks::Task_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Task.status)
}

// .ric.tasks.ObjectId object = 6;
inline bool Task::has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline void Task::clear_object() {
  if (GetArenaNoVirtual() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::ric::tasks::ObjectId& Task::object() const {
  const ::ric::tasks::ObjectId* p = object_;
  // @@protoc_insertion_point(field_get:ric.tasks.Task.object)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* Task::release_object() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.object)
  
  ::ric::tasks::ObjectId* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* Task::mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    object_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.object)
  return object_;
}
inline void Task::set_allocated_object(::ric::tasks::ObjectId* object) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.object)
}

// .ric.tasks.Location begin = 7;
inline bool Task::has_begin() const {
  return this != internal_default_instance() && begin_ != nullptr;
}
inline void Task::clear_begin() {
  if (GetArenaNoVirtual() == nullptr && begin_ != nullptr) {
    delete begin_;
  }
  begin_ = nullptr;
}
inline const ::ric::tasks::Location& Task::begin() const {
  const ::ric::tasks::Location* p = begin_;
  // @@protoc_insertion_point(field_get:ric.tasks.Task.begin)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::Location*>(
      &::ric::tasks::_Location_default_instance_);
}
inline ::ric::tasks::Location* Task::release_begin() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.begin)
  
  ::ric::tasks::Location* temp = begin_;
  begin_ = nullptr;
  return temp;
}
inline ::ric::tasks::Location* Task::mutable_begin() {
  
  if (begin_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::Location>(GetArenaNoVirtual());
    begin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.begin)
  return begin_;
}
inline void Task::set_allocated_begin(::ric::tasks::Location* begin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete begin_;
  }
  if (begin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      begin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, begin, submessage_arena);
    }
    
  } else {
    
  }
  begin_ = begin;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.begin)
}

// .ric.tasks.Location end = 8;
inline bool Task::has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline void Task::clear_end() {
  if (GetArenaNoVirtual() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::ric::tasks::Location& Task::end() const {
  const ::ric::tasks::Location* p = end_;
  // @@protoc_insertion_point(field_get:ric.tasks.Task.end)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::Location*>(
      &::ric::tasks::_Location_default_instance_);
}
inline ::ric::tasks::Location* Task::release_end() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.end)
  
  ::ric::tasks::Location* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::ric::tasks::Location* Task::mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::Location>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.end)
  return end_;
}
inline void Task::set_allocated_end(::ric::tasks::Location* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.end)
}

// int64 created_at = 9;
inline void Task::clear_created_at() {
  created_at_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Task::created_at() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.created_at)
  return created_at_;
}
inline void Task::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Task.created_at)
}

// repeated .ric.tasks.Deadline deadlines = 10;
inline int Task::deadlines_size() const {
  return deadlines_.size();
}
inline void Task::clear_deadlines() {
  deadlines_.Clear();
}
inline ::ric::tasks::Deadline* Task::mutable_deadlines(int index) {
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.deadlines)
  return deadlines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ric::tasks::Deadline >*
Task::mutable_deadlines() {
  // @@protoc_insertion_point(field_mutable_list:ric.tasks.Task.deadlines)
  return &deadlines_;
}
inline const ::ric::tasks::Deadline& Task::deadlines(int index) const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.deadlines)
  return deadlines_.Get(index);
}
inline ::ric::tasks::Deadline* Task::add_deadlines() {
  // @@protoc_insertion_point(field_add:ric.tasks.Task.deadlines)
  return deadlines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ric::tasks::Deadline >&
Task::deadlines() const {
  // @@protoc_insertion_point(field_list:ric.tasks.Task.deadlines)
  return deadlines_;
}

// .ric.tasks.ObjectId owner = 11;
inline bool Task::has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline void Task::clear_owner() {
  if (GetArenaNoVirtual() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
inline const ::ric::tasks::ObjectId& Task::owner() const {
  const ::ric::tasks::ObjectId* p = owner_;
  // @@protoc_insertion_point(field_get:ric.tasks.Task.owner)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* Task::release_owner() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.owner)
  
  ::ric::tasks::ObjectId* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* Task::mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    owner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.owner)
  return owner_;
}
inline void Task::set_allocated_owner(::ric::tasks::ObjectId* owner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete owner_;
  }
  if (owner) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.owner)
}

// .google.protobuf.BoolValue success = 12;
inline bool Task::has_success() const {
  return this != internal_default_instance() && success_ != nullptr;
}
inline const ::google::protobuf::BoolValue& Task::success() const {
  const ::google::protobuf::BoolValue* p = success_;
  // @@protoc_insertion_point(field_get:ric.tasks.Task.success)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* Task::release_success() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.success)
  
  ::google::protobuf::BoolValue* temp = success_;
  success_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* Task::mutable_success() {
  
  if (success_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    success_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.success)
  return success_;
}
inline void Task::set_allocated_success(::google::protobuf::BoolValue* success) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(success_);
  }
  if (success) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(success)->GetArena();
    if (message_arena != submessage_arena) {
      success = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, success, submessage_arena);
    }
    
  } else {
    
  }
  success_ = success;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.success)
}

// string comment = 13;
inline void Task::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Task::comment() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.comment)
  return comment_.GetNoArena();
}
inline void Task::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.Task.comment)
}
#if LANG_CXX11
inline void Task::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.Task.comment)
}
#endif
inline void Task::set_comment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.Task.comment)
}
inline void Task::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.Task.comment)
}
inline ::std::string* Task::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_comment() {
  // @@protoc_insertion_point(field_release:ric.tasks.Task.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_comment(::std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Task.comment)
}

// repeated string files = 14;
inline int Task::files_size() const {
  return files_.size();
}
inline void Task::clear_files() {
  files_.Clear();
}
inline const ::std::string& Task::files(int index) const {
  // @@protoc_insertion_point(field_get:ric.tasks.Task.files)
  return files_.Get(index);
}
inline ::std::string* Task::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:ric.tasks.Task.files)
  return files_.Mutable(index);
}
inline void Task::set_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.tasks.Task.files)
  files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Task::set_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.tasks.Task.files)
  files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Task::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.tasks.Task.files)
}
inline void Task::set_files(int index, const char* value, size_t size) {
  files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.Task.files)
}
inline ::std::string* Task::add_files() {
  // @@protoc_insertion_point(field_add_mutable:ric.tasks.Task.files)
  return files_.Add();
}
inline void Task::add_files(const ::std::string& value) {
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.tasks.Task.files)
}
#if LANG_CXX11
inline void Task::add_files(::std::string&& value) {
  files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.tasks.Task.files)
}
#endif
inline void Task::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.tasks.Task.files)
}
inline void Task::add_files(const char* value, size_t size) {
  files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.tasks.Task.files)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Task::files() const {
  // @@protoc_insertion_point(field_list:ric.tasks.Task.files)
  return files_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Task::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:ric.tasks.Task.files)
  return &files_;
}

// -------------------------------------------------------------------

// Deadline

// int64 timestamp = 1;
inline void Deadline::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Deadline::timestamp() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Deadline.timestamp)
  return timestamp_;
}
inline void Deadline::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Deadline.timestamp)
}

// .google.protobuf.Int64Value notify_until = 2;
inline bool Deadline::has_notify_until() const {
  return this != internal_default_instance() && notify_until_ != nullptr;
}
inline const ::google::protobuf::Int64Value& Deadline::notify_until() const {
  const ::google::protobuf::Int64Value* p = notify_until_;
  // @@protoc_insertion_point(field_get:ric.tasks.Deadline.notify_until)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* Deadline::release_notify_until() {
  // @@protoc_insertion_point(field_release:ric.tasks.Deadline.notify_until)
  
  ::google::protobuf::Int64Value* temp = notify_until_;
  notify_until_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* Deadline::mutable_notify_until() {
  
  if (notify_until_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    notify_until_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.Deadline.notify_until)
  return notify_until_;
}
inline void Deadline::set_allocated_notify_until(::google::protobuf::Int64Value* notify_until) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(notify_until_);
  }
  if (notify_until) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(notify_until)->GetArena();
    if (message_arena != submessage_arena) {
      notify_until = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, notify_until, submessage_arena);
    }
    
  } else {
    
  }
  notify_until_ = notify_until;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.Deadline.notify_until)
}

// .ric.tasks.Task.Status status = 3;
inline void Deadline::clear_status() {
  status_ = 0;
}
inline ::ric::tasks::Task_Status Deadline::status() const {
  // @@protoc_insertion_point(field_get:ric.tasks.Deadline.status)
  return static_cast< ::ric::tasks::Task_Status >(status_);
}
inline void Deadline::set_status(::ric::tasks::Task_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.Deadline.status)
}

// -------------------------------------------------------------------

// MasterTask

// .ric.tasks.ObjectId oid = 1;
inline bool MasterTask::has_oid() const {
  return this != internal_default_instance() && oid_ != nullptr;
}
inline void MasterTask::clear_oid() {
  if (GetArenaNoVirtual() == nullptr && oid_ != nullptr) {
    delete oid_;
  }
  oid_ = nullptr;
}
inline const ::ric::tasks::ObjectId& MasterTask::oid() const {
  const ::ric::tasks::ObjectId* p = oid_;
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.oid)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* MasterTask::release_oid() {
  // @@protoc_insertion_point(field_release:ric.tasks.MasterTask.oid)
  
  ::ric::tasks::ObjectId* temp = oid_;
  oid_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* MasterTask::mutable_oid() {
  
  if (oid_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    oid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.oid)
  return oid_;
}
inline void MasterTask::set_allocated_oid(::ric::tasks::ObjectId* oid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete oid_;
  }
  if (oid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      oid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, oid, submessage_arena);
    }
    
  } else {
    
  }
  oid_ = oid;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.MasterTask.oid)
}

// .ric.tasks.ObjectId owner = 2;
inline bool MasterTask::has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline void MasterTask::clear_owner() {
  if (GetArenaNoVirtual() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
inline const ::ric::tasks::ObjectId& MasterTask::owner() const {
  const ::ric::tasks::ObjectId* p = owner_;
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.owner)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* MasterTask::release_owner() {
  // @@protoc_insertion_point(field_release:ric.tasks.MasterTask.owner)
  
  ::ric::tasks::ObjectId* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* MasterTask::mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    owner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.owner)
  return owner_;
}
inline void MasterTask::set_allocated_owner(::ric::tasks::ObjectId* owner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete owner_;
  }
  if (owner) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.MasterTask.owner)
}

// .ric.tasks.ObjectId group = 3;
inline bool MasterTask::has_group() const {
  return this != internal_default_instance() && group_ != nullptr;
}
inline void MasterTask::clear_group() {
  if (GetArenaNoVirtual() == nullptr && group_ != nullptr) {
    delete group_;
  }
  group_ = nullptr;
}
inline const ::ric::tasks::ObjectId& MasterTask::group() const {
  const ::ric::tasks::ObjectId* p = group_;
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.group)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* MasterTask::release_group() {
  // @@protoc_insertion_point(field_release:ric.tasks.MasterTask.group)
  
  ::ric::tasks::ObjectId* temp = group_;
  group_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* MasterTask::mutable_group() {
  
  if (group_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.group)
  return group_;
}
inline void MasterTask::set_allocated_group(::ric::tasks::ObjectId* group) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete group_;
  }
  if (group) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      group = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.MasterTask.group)
}

// repeated .ric.tasks.Task subtasks = 4;
inline int MasterTask::subtasks_size() const {
  return subtasks_.size();
}
inline void MasterTask::clear_subtasks() {
  subtasks_.Clear();
}
inline ::ric::tasks::Task* MasterTask::mutable_subtasks(int index) {
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.subtasks)
  return subtasks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ric::tasks::Task >*
MasterTask::mutable_subtasks() {
  // @@protoc_insertion_point(field_mutable_list:ric.tasks.MasterTask.subtasks)
  return &subtasks_;
}
inline const ::ric::tasks::Task& MasterTask::subtasks(int index) const {
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.subtasks)
  return subtasks_.Get(index);
}
inline ::ric::tasks::Task* MasterTask::add_subtasks() {
  // @@protoc_insertion_point(field_add:ric.tasks.MasterTask.subtasks)
  return subtasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ric::tasks::Task >&
MasterTask::subtasks() const {
  // @@protoc_insertion_point(field_list:ric.tasks.MasterTask.subtasks)
  return subtasks_;
}

// .ric.tasks.MasterTask.Constrain constrain = 5;
inline void MasterTask::clear_constrain() {
  constrain_ = 0;
}
inline ::ric::tasks::MasterTask_Constrain MasterTask::constrain() const {
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.constrain)
  return static_cast< ::ric::tasks::MasterTask_Constrain >(constrain_);
}
inline void MasterTask::set_constrain(::ric::tasks::MasterTask_Constrain value) {
  
  constrain_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.MasterTask.constrain)
}

// repeated string tags = 6;
inline int MasterTask::tags_size() const {
  return tags_.size();
}
inline void MasterTask::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& MasterTask::tags(int index) const {
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.tags)
  return tags_.Get(index);
}
inline ::std::string* MasterTask::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.tags)
  return tags_.Mutable(index);
}
inline void MasterTask::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.tasks.MasterTask.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MasterTask::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.tasks.MasterTask.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MasterTask::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.tasks.MasterTask.tags)
}
inline void MasterTask::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.MasterTask.tags)
}
inline ::std::string* MasterTask::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:ric.tasks.MasterTask.tags)
  return tags_.Add();
}
inline void MasterTask::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.tasks.MasterTask.tags)
}
#if LANG_CXX11
inline void MasterTask::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.tasks.MasterTask.tags)
}
#endif
inline void MasterTask::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.tasks.MasterTask.tags)
}
inline void MasterTask::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.tasks.MasterTask.tags)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MasterTask::tags() const {
  // @@protoc_insertion_point(field_list:ric.tasks.MasterTask.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MasterTask::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:ric.tasks.MasterTask.tags)
  return &tags_;
}

// .ric.tasks.ObjectId assignee = 7;
inline bool MasterTask::has_assignee() const {
  return this != internal_default_instance() && assignee_ != nullptr;
}
inline void MasterTask::clear_assignee() {
  if (GetArenaNoVirtual() == nullptr && assignee_ != nullptr) {
    delete assignee_;
  }
  assignee_ = nullptr;
}
inline const ::ric::tasks::ObjectId& MasterTask::assignee() const {
  const ::ric::tasks::ObjectId* p = assignee_;
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.assignee)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* MasterTask::release_assignee() {
  // @@protoc_insertion_point(field_release:ric.tasks.MasterTask.assignee)
  
  ::ric::tasks::ObjectId* temp = assignee_;
  assignee_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* MasterTask::mutable_assignee() {
  
  if (assignee_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    assignee_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.assignee)
  return assignee_;
}
inline void MasterTask::set_allocated_assignee(::ric::tasks::ObjectId* assignee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete assignee_;
  }
  if (assignee) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      assignee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, assignee, submessage_arena);
    }
    
  } else {
    
  }
  assignee_ = assignee;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.MasterTask.assignee)
}

// .ric.tasks.MasterTask.Priority priority = 8;
inline void MasterTask::clear_priority() {
  priority_ = 0;
}
inline ::ric::tasks::MasterTask_Priority MasterTask::priority() const {
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.priority)
  return static_cast< ::ric::tasks::MasterTask_Priority >(priority_);
}
inline void MasterTask::set_priority(::ric::tasks::MasterTask_Priority value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.MasterTask.priority)
}

// int64 time = 9;
inline void MasterTask::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 MasterTask::time() const {
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.time)
  return time_;
}
inline void MasterTask::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.MasterTask.time)
}

// .ric.tasks.ObjectId object = 10;
inline bool MasterTask::has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline void MasterTask::clear_object() {
  if (GetArenaNoVirtual() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::ric::tasks::ObjectId& MasterTask::object() const {
  const ::ric::tasks::ObjectId* p = object_;
  // @@protoc_insertion_point(field_get:ric.tasks.MasterTask.object)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* MasterTask::release_object() {
  // @@protoc_insertion_point(field_release:ric.tasks.MasterTask.object)
  
  ::ric::tasks::ObjectId* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* MasterTask::mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    object_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.MasterTask.object)
  return object_;
}
inline void MasterTask::set_allocated_object(::ric::tasks::ObjectId* object) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.MasterTask.object)
}

// -------------------------------------------------------------------

// CreateRequest

// .ric.tasks.MasterTask master_task = 1;
inline bool CreateRequest::has_master_task() const {
  return this != internal_default_instance() && master_task_ != nullptr;
}
inline void CreateRequest::clear_master_task() {
  if (GetArenaNoVirtual() == nullptr && master_task_ != nullptr) {
    delete master_task_;
  }
  master_task_ = nullptr;
}
inline const ::ric::tasks::MasterTask& CreateRequest::master_task() const {
  const ::ric::tasks::MasterTask* p = master_task_;
  // @@protoc_insertion_point(field_get:ric.tasks.CreateRequest.master_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::MasterTask*>(
      &::ric::tasks::_MasterTask_default_instance_);
}
inline ::ric::tasks::MasterTask* CreateRequest::release_master_task() {
  // @@protoc_insertion_point(field_release:ric.tasks.CreateRequest.master_task)
  
  ::ric::tasks::MasterTask* temp = master_task_;
  master_task_ = nullptr;
  return temp;
}
inline ::ric::tasks::MasterTask* CreateRequest::mutable_master_task() {
  
  if (master_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::MasterTask>(GetArenaNoVirtual());
    master_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.CreateRequest.master_task)
  return master_task_;
}
inline void CreateRequest::set_allocated_master_task(::ric::tasks::MasterTask* master_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete master_task_;
  }
  if (master_task) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      master_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master_task, submessage_arena);
    }
    
  } else {
    
  }
  master_task_ = master_task;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.CreateRequest.master_task)
}

// -------------------------------------------------------------------

// CreateResponse

// .ric.tasks.ObjectId oid = 1;
inline bool CreateResponse::has_oid() const {
  return this != internal_default_instance() && oid_ != nullptr;
}
inline void CreateResponse::clear_oid() {
  if (GetArenaNoVirtual() == nullptr && oid_ != nullptr) {
    delete oid_;
  }
  oid_ = nullptr;
}
inline const ::ric::tasks::ObjectId& CreateResponse::oid() const {
  const ::ric::tasks::ObjectId* p = oid_;
  // @@protoc_insertion_point(field_get:ric.tasks.CreateResponse.oid)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* CreateResponse::release_oid() {
  // @@protoc_insertion_point(field_release:ric.tasks.CreateResponse.oid)
  
  ::ric::tasks::ObjectId* temp = oid_;
  oid_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* CreateResponse::mutable_oid() {
  
  if (oid_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    oid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.CreateResponse.oid)
  return oid_;
}
inline void CreateResponse::set_allocated_oid(::ric::tasks::ObjectId* oid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete oid_;
  }
  if (oid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      oid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, oid, submessage_arena);
    }
    
  } else {
    
  }
  oid_ = oid;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.CreateResponse.oid)
}

// repeated .ric.tasks.TaskId sub_ids = 2;
inline int CreateResponse::sub_ids_size() const {
  return sub_ids_.size();
}
inline void CreateResponse::clear_sub_ids() {
  sub_ids_.Clear();
}
inline ::ric::tasks::TaskId* CreateResponse::mutable_sub_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ric.tasks.CreateResponse.sub_ids)
  return sub_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ric::tasks::TaskId >*
CreateResponse::mutable_sub_ids() {
  // @@protoc_insertion_point(field_mutable_list:ric.tasks.CreateResponse.sub_ids)
  return &sub_ids_;
}
inline const ::ric::tasks::TaskId& CreateResponse::sub_ids(int index) const {
  // @@protoc_insertion_point(field_get:ric.tasks.CreateResponse.sub_ids)
  return sub_ids_.Get(index);
}
inline ::ric::tasks::TaskId* CreateResponse::add_sub_ids() {
  // @@protoc_insertion_point(field_add:ric.tasks.CreateResponse.sub_ids)
  return sub_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ric::tasks::TaskId >&
CreateResponse::sub_ids() const {
  // @@protoc_insertion_point(field_list:ric.tasks.CreateResponse.sub_ids)
  return sub_ids_;
}

// -------------------------------------------------------------------

// GetRequest

// .ric.tasks.ObjectId oid = 1;
inline bool GetRequest::has_oid() const {
  return payload_case() == kOid;
}
inline void GetRequest::set_has_oid() {
  _oneof_case_[0] = kOid;
}
inline void GetRequest::clear_oid() {
  if (has_oid()) {
    delete payload_.oid_;
    clear_has_payload();
  }
}
inline ::ric::tasks::ObjectId* GetRequest::release_oid() {
  // @@protoc_insertion_point(field_release:ric.tasks.GetRequest.oid)
  if (has_oid()) {
    clear_has_payload();
      ::ric::tasks::ObjectId* temp = payload_.oid_;
    payload_.oid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ric::tasks::ObjectId& GetRequest::oid() const {
  // @@protoc_insertion_point(field_get:ric.tasks.GetRequest.oid)
  return has_oid()
      ? *payload_.oid_
      : *reinterpret_cast< ::ric::tasks::ObjectId*>(&::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* GetRequest::mutable_oid() {
  if (!has_oid()) {
    clear_payload();
    set_has_oid();
    payload_.oid_ = CreateMaybeMessage< ::ric::tasks::ObjectId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.GetRequest.oid)
  return payload_.oid_;
}

// .ric.tasks.TaskId tid = 2;
inline bool GetRequest::has_tid() const {
  return payload_case() == kTid;
}
inline void GetRequest::set_has_tid() {
  _oneof_case_[0] = kTid;
}
inline void GetRequest::clear_tid() {
  if (has_tid()) {
    delete payload_.tid_;
    clear_has_payload();
  }
}
inline ::ric::tasks::TaskId* GetRequest::release_tid() {
  // @@protoc_insertion_point(field_release:ric.tasks.GetRequest.tid)
  if (has_tid()) {
    clear_has_payload();
      ::ric::tasks::TaskId* temp = payload_.tid_;
    payload_.tid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ric::tasks::TaskId& GetRequest::tid() const {
  // @@protoc_insertion_point(field_get:ric.tasks.GetRequest.tid)
  return has_tid()
      ? *payload_.tid_
      : *reinterpret_cast< ::ric::tasks::TaskId*>(&::ric::tasks::_TaskId_default_instance_);
}
inline ::ric::tasks::TaskId* GetRequest::mutable_tid() {
  if (!has_tid()) {
    clear_payload();
    set_has_tid();
    payload_.tid_ = CreateMaybeMessage< ::ric::tasks::TaskId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.GetRequest.tid)
  return payload_.tid_;
}

inline bool GetRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void GetRequest::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline GetRequest::PayloadCase GetRequest::payload_case() const {
  return GetRequest::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponse

// .ric.tasks.MasterTask master_task = 1;
inline bool GetResponse::has_master_task() const {
  return this != internal_default_instance() && master_task_ != nullptr;
}
inline void GetResponse::clear_master_task() {
  if (GetArenaNoVirtual() == nullptr && master_task_ != nullptr) {
    delete master_task_;
  }
  master_task_ = nullptr;
}
inline const ::ric::tasks::MasterTask& GetResponse::master_task() const {
  const ::ric::tasks::MasterTask* p = master_task_;
  // @@protoc_insertion_point(field_get:ric.tasks.GetResponse.master_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::MasterTask*>(
      &::ric::tasks::_MasterTask_default_instance_);
}
inline ::ric::tasks::MasterTask* GetResponse::release_master_task() {
  // @@protoc_insertion_point(field_release:ric.tasks.GetResponse.master_task)
  
  ::ric::tasks::MasterTask* temp = master_task_;
  master_task_ = nullptr;
  return temp;
}
inline ::ric::tasks::MasterTask* GetResponse::mutable_master_task() {
  
  if (master_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::MasterTask>(GetArenaNoVirtual());
    master_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.GetResponse.master_task)
  return master_task_;
}
inline void GetResponse::set_allocated_master_task(::ric::tasks::MasterTask* master_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete master_task_;
  }
  if (master_task) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      master_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master_task, submessage_arena);
    }
    
  } else {
    
  }
  master_task_ = master_task;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.GetResponse.master_task)
}

// -------------------------------------------------------------------

// DeleteRequest

// .ric.tasks.ObjectId oid = 1;
inline bool DeleteRequest::has_oid() const {
  return payload_case() == kOid;
}
inline void DeleteRequest::set_has_oid() {
  _oneof_case_[0] = kOid;
}
inline void DeleteRequest::clear_oid() {
  if (has_oid()) {
    delete payload_.oid_;
    clear_has_payload();
  }
}
inline ::ric::tasks::ObjectId* DeleteRequest::release_oid() {
  // @@protoc_insertion_point(field_release:ric.tasks.DeleteRequest.oid)
  if (has_oid()) {
    clear_has_payload();
      ::ric::tasks::ObjectId* temp = payload_.oid_;
    payload_.oid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ric::tasks::ObjectId& DeleteRequest::oid() const {
  // @@protoc_insertion_point(field_get:ric.tasks.DeleteRequest.oid)
  return has_oid()
      ? *payload_.oid_
      : *reinterpret_cast< ::ric::tasks::ObjectId*>(&::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* DeleteRequest::mutable_oid() {
  if (!has_oid()) {
    clear_payload();
    set_has_oid();
    payload_.oid_ = CreateMaybeMessage< ::ric::tasks::ObjectId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.DeleteRequest.oid)
  return payload_.oid_;
}

// .ric.tasks.TaskId tid = 2;
inline bool DeleteRequest::has_tid() const {
  return payload_case() == kTid;
}
inline void DeleteRequest::set_has_tid() {
  _oneof_case_[0] = kTid;
}
inline void DeleteRequest::clear_tid() {
  if (has_tid()) {
    delete payload_.tid_;
    clear_has_payload();
  }
}
inline ::ric::tasks::TaskId* DeleteRequest::release_tid() {
  // @@protoc_insertion_point(field_release:ric.tasks.DeleteRequest.tid)
  if (has_tid()) {
    clear_has_payload();
      ::ric::tasks::TaskId* temp = payload_.tid_;
    payload_.tid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ric::tasks::TaskId& DeleteRequest::tid() const {
  // @@protoc_insertion_point(field_get:ric.tasks.DeleteRequest.tid)
  return has_tid()
      ? *payload_.tid_
      : *reinterpret_cast< ::ric::tasks::TaskId*>(&::ric::tasks::_TaskId_default_instance_);
}
inline ::ric::tasks::TaskId* DeleteRequest::mutable_tid() {
  if (!has_tid()) {
    clear_payload();
    set_has_tid();
    payload_.tid_ = CreateMaybeMessage< ::ric::tasks::TaskId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.DeleteRequest.tid)
  return payload_.tid_;
}

inline bool DeleteRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void DeleteRequest::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline DeleteRequest::PayloadCase DeleteRequest::payload_case() const {
  return DeleteRequest::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DeleteResponse

// -------------------------------------------------------------------

// UpdateRequest

// .ric.tasks.MasterTask master_task = 1;
inline bool UpdateRequest::has_master_task() const {
  return this != internal_default_instance() && master_task_ != nullptr;
}
inline void UpdateRequest::clear_master_task() {
  if (GetArenaNoVirtual() == nullptr && master_task_ != nullptr) {
    delete master_task_;
  }
  master_task_ = nullptr;
}
inline const ::ric::tasks::MasterTask& UpdateRequest::master_task() const {
  const ::ric::tasks::MasterTask* p = master_task_;
  // @@protoc_insertion_point(field_get:ric.tasks.UpdateRequest.master_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::MasterTask*>(
      &::ric::tasks::_MasterTask_default_instance_);
}
inline ::ric::tasks::MasterTask* UpdateRequest::release_master_task() {
  // @@protoc_insertion_point(field_release:ric.tasks.UpdateRequest.master_task)
  
  ::ric::tasks::MasterTask* temp = master_task_;
  master_task_ = nullptr;
  return temp;
}
inline ::ric::tasks::MasterTask* UpdateRequest::mutable_master_task() {
  
  if (master_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::MasterTask>(GetArenaNoVirtual());
    master_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.UpdateRequest.master_task)
  return master_task_;
}
inline void UpdateRequest::set_allocated_master_task(::ric::tasks::MasterTask* master_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete master_task_;
  }
  if (master_task) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      master_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master_task, submessage_arena);
    }
    
  } else {
    
  }
  master_task_ = master_task;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.UpdateRequest.master_task)
}

// -------------------------------------------------------------------

// UpdateResponse

// .ric.tasks.MasterTask master_task = 1;
inline bool UpdateResponse::has_master_task() const {
  return this != internal_default_instance() && master_task_ != nullptr;
}
inline void UpdateResponse::clear_master_task() {
  if (GetArenaNoVirtual() == nullptr && master_task_ != nullptr) {
    delete master_task_;
  }
  master_task_ = nullptr;
}
inline const ::ric::tasks::MasterTask& UpdateResponse::master_task() const {
  const ::ric::tasks::MasterTask* p = master_task_;
  // @@protoc_insertion_point(field_get:ric.tasks.UpdateResponse.master_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::MasterTask*>(
      &::ric::tasks::_MasterTask_default_instance_);
}
inline ::ric::tasks::MasterTask* UpdateResponse::release_master_task() {
  // @@protoc_insertion_point(field_release:ric.tasks.UpdateResponse.master_task)
  
  ::ric::tasks::MasterTask* temp = master_task_;
  master_task_ = nullptr;
  return temp;
}
inline ::ric::tasks::MasterTask* UpdateResponse::mutable_master_task() {
  
  if (master_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::MasterTask>(GetArenaNoVirtual());
    master_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.UpdateResponse.master_task)
  return master_task_;
}
inline void UpdateResponse::set_allocated_master_task(::ric::tasks::MasterTask* master_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete master_task_;
  }
  if (master_task) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      master_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, master_task, submessage_arena);
    }
    
  } else {
    
  }
  master_task_ = master_task;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.UpdateResponse.master_task)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateOrderRequest

// .ric.tasks.ObjectId id = 1;
inline bool UpdateOrderRequest::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline void UpdateOrderRequest::clear_id() {
  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::ric::tasks::ObjectId& UpdateOrderRequest::id() const {
  const ::ric::tasks::ObjectId* p = id_;
  // @@protoc_insertion_point(field_get:ric.tasks.UpdateOrderRequest.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::ObjectId*>(
      &::ric::tasks::_ObjectId_default_instance_);
}
inline ::ric::tasks::ObjectId* UpdateOrderRequest::release_id() {
  // @@protoc_insertion_point(field_release:ric.tasks.UpdateOrderRequest.id)
  
  ::ric::tasks::ObjectId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::ric::tasks::ObjectId* UpdateOrderRequest::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::ObjectId>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.UpdateOrderRequest.id)
  return id_;
}
inline void UpdateOrderRequest::set_allocated_id(::ric::tasks::ObjectId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.UpdateOrderRequest.id)
}

// map<int32, .ric.tasks.TaskId> positions = 2;
inline int UpdateOrderRequest::positions_size() const {
  return positions_.size();
}
inline void UpdateOrderRequest::clear_positions() {
  positions_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::ric::tasks::TaskId >&
UpdateOrderRequest::positions() const {
  // @@protoc_insertion_point(field_map:ric.tasks.UpdateOrderRequest.positions)
  return positions_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::ric::tasks::TaskId >*
UpdateOrderRequest::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_map:ric.tasks.UpdateOrderRequest.positions)
  return positions_.MutableMap();
}

// -------------------------------------------------------------------

// UpdateOrderResponse

// -------------------------------------------------------------------

// ChangeStatusRequest

// .ric.tasks.TaskId id = 1;
inline bool ChangeStatusRequest::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline void ChangeStatusRequest::clear_id() {
  if (GetArenaNoVirtual() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::ric::tasks::TaskId& ChangeStatusRequest::id() const {
  const ::ric::tasks::TaskId* p = id_;
  // @@protoc_insertion_point(field_get:ric.tasks.ChangeStatusRequest.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::TaskId*>(
      &::ric::tasks::_TaskId_default_instance_);
}
inline ::ric::tasks::TaskId* ChangeStatusRequest::release_id() {
  // @@protoc_insertion_point(field_release:ric.tasks.ChangeStatusRequest.id)
  
  ::ric::tasks::TaskId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::ric::tasks::TaskId* ChangeStatusRequest::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::TaskId>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.ChangeStatusRequest.id)
  return id_;
}
inline void ChangeStatusRequest::set_allocated_id(::ric::tasks::TaskId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.ChangeStatusRequest.id)
}

// .ric.tasks.Task.Status new_status = 2;
inline void ChangeStatusRequest::clear_new_status() {
  new_status_ = 0;
}
inline ::ric::tasks::Task_Status ChangeStatusRequest::new_status() const {
  // @@protoc_insertion_point(field_get:ric.tasks.ChangeStatusRequest.new_status)
  return static_cast< ::ric::tasks::Task_Status >(new_status_);
}
inline void ChangeStatusRequest::set_new_status(::ric::tasks::Task_Status value) {
  
  new_status_ = value;
  // @@protoc_insertion_point(field_set:ric.tasks.ChangeStatusRequest.new_status)
}

// .ric.tasks.Location location = 3;
inline bool ChangeStatusRequest::has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline void ChangeStatusRequest::clear_location() {
  if (GetArenaNoVirtual() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::ric::tasks::Location& ChangeStatusRequest::location() const {
  const ::ric::tasks::Location* p = location_;
  // @@protoc_insertion_point(field_get:ric.tasks.ChangeStatusRequest.location)
  return p != nullptr ? *p : *reinterpret_cast<const ::ric::tasks::Location*>(
      &::ric::tasks::_Location_default_instance_);
}
inline ::ric::tasks::Location* ChangeStatusRequest::release_location() {
  // @@protoc_insertion_point(field_release:ric.tasks.ChangeStatusRequest.location)
  
  ::ric::tasks::Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::ric::tasks::Location* ChangeStatusRequest::mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::ric::tasks::Location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.ChangeStatusRequest.location)
  return location_;
}
inline void ChangeStatusRequest::set_allocated_location(::ric::tasks::Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.ChangeStatusRequest.location)
}

// .google.protobuf.BoolValue success = 4;
inline bool ChangeStatusRequest::has_success() const {
  return this != internal_default_instance() && success_ != nullptr;
}
inline const ::google::protobuf::BoolValue& ChangeStatusRequest::success() const {
  const ::google::protobuf::BoolValue* p = success_;
  // @@protoc_insertion_point(field_get:ric.tasks.ChangeStatusRequest.success)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ChangeStatusRequest::release_success() {
  // @@protoc_insertion_point(field_release:ric.tasks.ChangeStatusRequest.success)
  
  ::google::protobuf::BoolValue* temp = success_;
  success_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* ChangeStatusRequest::mutable_success() {
  
  if (success_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    success_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ric.tasks.ChangeStatusRequest.success)
  return success_;
}
inline void ChangeStatusRequest::set_allocated_success(::google::protobuf::BoolValue* success) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(success_);
  }
  if (success) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(success)->GetArena();
    if (message_arena != submessage_arena) {
      success = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, success, submessage_arena);
    }
    
  } else {
    
  }
  success_ = success;
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.ChangeStatusRequest.success)
}

// string comment = 5;
inline void ChangeStatusRequest::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeStatusRequest::comment() const {
  // @@protoc_insertion_point(field_get:ric.tasks.ChangeStatusRequest.comment)
  return comment_.GetNoArena();
}
inline void ChangeStatusRequest::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ric.tasks.ChangeStatusRequest.comment)
}
#if LANG_CXX11
inline void ChangeStatusRequest::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ric.tasks.ChangeStatusRequest.comment)
}
#endif
inline void ChangeStatusRequest::set_comment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ric.tasks.ChangeStatusRequest.comment)
}
inline void ChangeStatusRequest::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.ChangeStatusRequest.comment)
}
inline ::std::string* ChangeStatusRequest::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:ric.tasks.ChangeStatusRequest.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatusRequest::release_comment() {
  // @@protoc_insertion_point(field_release:ric.tasks.ChangeStatusRequest.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusRequest::set_allocated_comment(::std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:ric.tasks.ChangeStatusRequest.comment)
}

// repeated string files = 6;
inline int ChangeStatusRequest::files_size() const {
  return files_.size();
}
inline void ChangeStatusRequest::clear_files() {
  files_.Clear();
}
inline const ::std::string& ChangeStatusRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:ric.tasks.ChangeStatusRequest.files)
  return files_.Get(index);
}
inline ::std::string* ChangeStatusRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:ric.tasks.ChangeStatusRequest.files)
  return files_.Mutable(index);
}
inline void ChangeStatusRequest::set_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ric.tasks.ChangeStatusRequest.files)
  files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ChangeStatusRequest::set_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ric.tasks.ChangeStatusRequest.files)
  files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ChangeStatusRequest::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ric.tasks.ChangeStatusRequest.files)
}
inline void ChangeStatusRequest::set_files(int index, const char* value, size_t size) {
  files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ric.tasks.ChangeStatusRequest.files)
}
inline ::std::string* ChangeStatusRequest::add_files() {
  // @@protoc_insertion_point(field_add_mutable:ric.tasks.ChangeStatusRequest.files)
  return files_.Add();
}
inline void ChangeStatusRequest::add_files(const ::std::string& value) {
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ric.tasks.ChangeStatusRequest.files)
}
#if LANG_CXX11
inline void ChangeStatusRequest::add_files(::std::string&& value) {
  files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ric.tasks.ChangeStatusRequest.files)
}
#endif
inline void ChangeStatusRequest::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ric.tasks.ChangeStatusRequest.files)
}
inline void ChangeStatusRequest::add_files(const char* value, size_t size) {
  files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ric.tasks.ChangeStatusRequest.files)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ChangeStatusRequest::files() const {
  // @@protoc_insertion_point(field_list:ric.tasks.ChangeStatusRequest.files)
  return files_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ChangeStatusRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:ric.tasks.ChangeStatusRequest.files)
  return &files_;
}

// -------------------------------------------------------------------

// ChangeStatusResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tasks
}  // namespace ric

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ric::tasks::Task_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ric::tasks::Task_Status>() {
  return ::ric::tasks::Task_Status_descriptor();
}
template <> struct is_proto_enum< ::ric::tasks::MasterTask_Constrain> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ric::tasks::MasterTask_Constrain>() {
  return ::ric::tasks::MasterTask_Constrain_descriptor();
}
template <> struct is_proto_enum< ::ric::tasks::MasterTask_Priority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ric::tasks::MasterTask_Priority>() {
  return ::ric::tasks::MasterTask_Priority_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_ric_2dtasks_2frictasks_2eproto
